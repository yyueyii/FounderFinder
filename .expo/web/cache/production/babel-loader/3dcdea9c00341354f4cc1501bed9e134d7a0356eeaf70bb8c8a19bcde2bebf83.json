{"ast":null,"code":"\"use strict\";var _defineProperty=require(\"@babel/runtime/helpers/defineProperty\");var _objectWithoutProperties=require(\"@babel/runtime/helpers/objectWithoutProperties\");const _excluded=[\"preserveGroups\",\"preserveDynamicRoutes\"];function ownKeys(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);r&&(o=o.filter(function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable;})),t.push.apply(t,o);}return t;}function _objectSpread(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?ownKeys(Object(t),!0).forEach(function(r){_defineProperty(e,r,t[r]);}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):ownKeys(Object(t)).forEach(function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r));});}return e;}Object.defineProperty(exports,\"__esModule\",{value:true});exports.appendBaseUrl=exports.deepEqual=exports.getPathDataFromState=void 0;const core_1=require(\"@react-navigation/core\");const matchers_1=require(\"../matchers\");const DEFAULT_SCREENS={};const getActiveRoute=state=>{const route=typeof state.index==='number'?state.routes[state.index]:state.routes[state.routes.length-1];if(route.state){return getActiveRoute(route.state);}if(route&&isInvalidParams(route.params)){return getActiveRoute(createFakeState(route.params));}return route;};function createFakeState(params){return{stale:false,type:'UNKNOWN',key:'UNKNOWN',index:0,routeNames:[],routes:[{key:'UNKNOWN',name:params.screen,params:params.params,path:params.path}]};}function segmentMatchesConvention(segment){return segment==='index'||(0,matchers_1.matchDynamicName)(segment)!=null||(0,matchers_1.matchGroupName)(segment)!=null||(0,matchers_1.matchDeepDynamicRouteName)(segment)!=null;}function encodeURIComponentPreservingBrackets(str){return encodeURIComponent(str).replace(/%5B/g,'[').replace(/%5D/g,']');}function getPathFromState(state,_options){return getPathDataFromState(state,_options).path;}exports.default=getPathFromState;function getPathDataFromState(state,_options={screens:DEFAULT_SCREENS}){if(state==null){throw Error(\"Got 'undefined' for the navigation state. You must pass a valid state object.\");}const{preserveGroups,preserveDynamicRoutes}=_options,options=_objectWithoutProperties(_options,_excluded);(0,core_1.validatePathConfig)(options);if(Object.is(options.screens,DEFAULT_SCREENS)){throw Error(\"You must pass a 'screens' object to 'getPathFromState' to generate a path.\");}return getPathFromResolvedState(JSON.parse(JSON.stringify(state)),createNormalizedConfigs(options.screens),{preserveGroups,preserveDynamicRoutes});}exports.getPathDataFromState=getPathDataFromState;function processParamsWithUserSettings(configItem,params){const stringify=configItem?.stringify;return Object.fromEntries(Object.entries(params).map(([key,value])=>[key,stringify?.[key]?stringify[key](value):Array.isArray(value)?value:String(value)]));}function deepEqual(a,b){if(a===b){return true;}if(Array.isArray(a)&&Array.isArray(b)){if(a.length!==b.length){return false;}for(let i=0;i<a.length;i++){if(!deepEqual(a[i],b[i])){return false;}}return true;}if(typeof a==='object'&&typeof b==='object'){const keysA=Object.keys(a);const keysB=Object.keys(b);if(keysA.length!==keysB.length){return false;}for(const key of keysA){if(!deepEqual(a[key],b[key])){return false;}}return true;}return false;}exports.deepEqual=deepEqual;function walkConfigItems(route,focusedRoute,configs,{preserveDynamicRoutes}){if(!route.state&&isInvalidParams(route.params)){route.state=createFakeState(route.params);}let pattern=null;let focusedParams;let hash;const collectedParams={};while(route.name in configs){const configItem=configs[route.name];const inputPattern=configItem.pattern;if(inputPattern==null){throw new Error('Unexpected: No pattern found for route '+route.name);}pattern=inputPattern;if(route.params){if(route.params['#']){hash=route.params['#'];delete route.params['#'];}const params=processParamsWithUserSettings(configItem,route.params);if(pattern!==undefined&&pattern!==null){Object.assign(collectedParams,params);}if(deepEqual(focusedRoute,route)){if(preserveDynamicRoutes){focusedParams=params;}else{focusedParams=getParamsWithConventionsCollapsed({params,pattern,routeName:route.name});}}}if(!route.state&&isInvalidParams(route.params)){route.state=createFakeState(route.params);}if(!configItem.screens||route.state===undefined){if(configItem.initialRouteName&&configItem.screens&&configItem.initialRouteName in configItem.screens&&configItem.screens[configItem.initialRouteName]?.pattern){const initialRouteConfig=configItem.screens[configItem.initialRouteName];pattern=initialRouteConfig.pattern;if(focusedParams){if(!preserveDynamicRoutes){focusedParams=getParamsWithConventionsCollapsed({params:focusedParams,pattern,routeName:route.name});}}}break;}const index=route.state.index??route.state.routes.length-1;const nextRoute=route.state.routes[index];const nestedScreens=configItem.screens;if(nestedScreens&&nextRoute.name in nestedScreens){route=nextRoute;configs=nestedScreens;}else{break;}}if(pattern==null){throw new Error(`No pattern found for route \"${route.name}\". Options are: ${Object.keys(configs).join(', ')}.`);}if(pattern&&!focusedParams&&focusedRoute.params){if(preserveDynamicRoutes){focusedParams=focusedRoute.params;}else{focusedParams=getParamsWithConventionsCollapsed({params:focusedRoute.params,pattern,routeName:route.name});}Object.assign(focusedParams,collectedParams);}return{pattern,nextRoute:route,focusedParams,hash,params:collectedParams};}function getPathFromResolvedState(state,configs,{preserveGroups,preserveDynamicRoutes}){let path='';let current=state;let hash;const allParams={};while(current){path+='/';const route=current.routes[current.index??0];if(!route.state&&isInvalidParams(route.params)){route.state=createFakeState(route.params);}const{pattern,params,nextRoute,focusedParams,hash:$hash}=walkConfigItems(route,getActiveRoute(current),_objectSpread({},configs),{preserveDynamicRoutes});if($hash){hash=$hash;}Object.assign(allParams,params);path+=getPathWithConventionsCollapsed({pattern,routePath:nextRoute.path,params:allParams,initialRouteName:configs[nextRoute.name]?.initialRouteName,preserveGroups,preserveDynamicRoutes});if(nextRoute.state&&configs[nextRoute.state.routes?.[nextRoute.state?.index??0]?.name]){current=nextRoute.state;}else{if(focusedParams){for(const param in focusedParams){if(focusedParams[param]==='undefined'){delete focusedParams[param];}}const query=new URLSearchParams(focusedParams).toString();if(query){path+=`?${query}`;}}break;}}if(hash){allParams['#']=hash;path+=`#${hash}`;}const params=decodeParams(allParams);return{path:appendBaseUrl(basicSanitizePath(path)),params};}function decodeParams(params){const parsed={};for(const[key,value]of Object.entries(params)){try{if(Array.isArray(value)){parsed[key]=value.map(v=>decodeURIComponent(v));}else{parsed[key]=decodeURIComponent(value);}}catch{parsed[key]=value;}}return parsed;}function getPathWithConventionsCollapsed({pattern,routePath,params,preserveGroups,preserveDynamicRoutes,initialRouteName}){const segments=pattern.split('/');return segments.map((p,i)=>{const name=getParamName(p);if(p.startsWith('*')){if(preserveDynamicRoutes){if(name==='not-found'){return'+not-found';}return`[...${name}]`;}if(params[name]){if(Array.isArray(params[name])){return params[name].join('/');}return params[name];}if(i===0){return routePath;}return routePath?.split('/').slice(i+1).join('/');}if(p.startsWith(':')){if(preserveDynamicRoutes){return`[${name}]`;}return params[name];}if(!preserveGroups&&(0,matchers_1.matchGroupName)(p)!=null){if(segments.length-1===i){if(initialRouteName){if(segmentMatchesConvention(initialRouteName)){return'';}return encodeURIComponentPreservingBrackets(initialRouteName);}}return'';}return encodeURIComponentPreservingBrackets(p);}).map(v=>v??'').join('/');}function getParamsWithConventionsCollapsed({pattern,routeName,params}){const processedParams=_objectSpread({},params);const segments=pattern.split('/');segments.filter(segment=>segment.startsWith(':')).forEach(segment=>{const name=getParamName(segment);delete processedParams[name];});if(segments.some(segment=>segment.startsWith('*'))){const name=(0,matchers_1.testNotFound)(routeName)?'not-found':(0,matchers_1.matchDeepDynamicRouteName)(routeName)??routeName;delete processedParams[name];}return processedParams;}function basicSanitizePath(path){const simplifiedPath=path.replace(/\\/+/g,'/');if(simplifiedPath.length<=1){return simplifiedPath;}return simplifiedPath.replace(/\\/$/,'');}function isInvalidParams(params){if(!params){return false;}if('params'in params&&typeof params.params==='object'&&!!params.params){return true;}return'initial'in params&&typeof params.initial==='boolean'&&'screen'in params;}const getParamName=pattern=>pattern.replace(/^[:*]/,'').replace(/\\?$/,'');const joinPaths=(...paths)=>[].concat(...paths.map(p=>p.split('/'))).filter(Boolean).join('/');const createConfigItem=(config,parentPattern)=>{if(typeof config==='string'){const pattern=parentPattern?joinPaths(parentPattern,config):config;return{pattern};}if(config.exact&&config.path===undefined){throw new Error(\"A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. `path: ''`.\");}const pattern=config.exact!==true?joinPaths(parentPattern||'',config.path||''):config.path||'';const screens=config.screens?createNormalizedConfigs(config.screens,pattern):undefined;return{pattern:pattern?.split('/').filter(Boolean).join('/'),stringify:config.stringify,screens,initialRouteName:config.initialRouteName};};const createNormalizedConfigs=(options,pattern)=>Object.fromEntries(Object.entries(options).map(([name,c])=>[name,createConfigItem(c,pattern)]));function appendBaseUrl(path,baseUrl=\"\"){if(true){if(baseUrl){return`/${baseUrl.replace(/^\\/+/,'').replace(/\\/$/,'')}${path}`;}}return path;}exports.appendBaseUrl=appendBaseUrl;","map":{"version":3,"names":["core_1","require","matchers_1","DEFAULT_SCREENS","getActiveRoute","state","route","index","routes","length","isInvalidParams","params","createFakeState","stale","type","key","routeNames","name","screen","path","segmentMatchesConvention","segment","matchDynamicName","matchGroupName","matchDeepDynamicRouteName","encodeURIComponentPreservingBrackets","str","encodeURIComponent","replace","getPathFromState","_options","getPathDataFromState","exports","default","screens","Error","preserveGroups","preserveDynamicRoutes","options","_objectWithoutProperties","_excluded","validatePathConfig","Object","is","getPathFromResolvedState","JSON","parse","stringify","createNormalizedConfigs","processParamsWithUserSettings","configItem","fromEntries","entries","map","value","Array","isArray","String","deepEqual","a","b","i","keysA","keys","keysB","walkConfigItems","focusedRoute","configs","pattern","focusedParams","hash","collectedParams","inputPattern","undefined","assign","getParamsWithConventionsCollapsed","routeName","initialRouteName","initialRouteConfig","nextRoute","nestedScreens","join","current","allParams","$hash","_objectSpread","getPathWithConventionsCollapsed","routePath","param","query","URLSearchParams","toString","decodeParams","appendBaseUrl","basicSanitizePath","parsed","v","decodeURIComponent","segments","split","p","getParamName","startsWith","slice","processedParams","filter","forEach","some","testNotFound","simplifiedPath","initial","joinPaths","paths","concat","Boolean","createConfigItem","config","parentPattern","exact","c","baseUrl"],"sources":["/Users/apple/FounderFinder/node_modules/expo-router/src/fork/getPathFromState.ts"],"sourcesContent":["import { PathConfig, PathConfigMap, validatePathConfig } from '@react-navigation/core';\nimport type { NavigationState, PartialState, Route } from '@react-navigation/routers';\n\nimport {\n  matchDeepDynamicRouteName,\n  matchDynamicName,\n  matchGroupName,\n  testNotFound,\n} from '../matchers';\n\ntype Options<ParamList extends object> = {\n  initialRouteName?: string;\n  screens: PathConfigMap<ParamList>;\n};\n\nexport type State = NavigationState | Omit<PartialState<NavigationState>, 'stale'>;\n\ntype StringifyConfig = Record<string, (value: any) => string>;\n\ntype ConfigItem = {\n  pattern?: string;\n  stringify?: StringifyConfig;\n  screens?: Record<string, ConfigItem>;\n  // Used as fallback for groups\n  initialRouteName?: string;\n};\n\ntype CustomRoute = Route<string> & {\n  state?: State;\n};\n\nconst DEFAULT_SCREENS: PathConfigMap<object> = {};\n\nconst getActiveRoute = (state: State): { name: string; params?: object } => {\n  const route =\n    typeof state.index === 'number'\n      ? state.routes[state.index]\n      : state.routes[state.routes.length - 1];\n\n  if (route.state) {\n    return getActiveRoute(route.state);\n  }\n\n  if (route && isInvalidParams(route.params)) {\n    return getActiveRoute(createFakeState(route.params));\n  }\n\n  return route;\n};\n\nfunction createFakeState(params: StateAsParams) {\n  return {\n    stale: false,\n    type: 'UNKNOWN',\n    key: 'UNKNOWN',\n    index: 0,\n    routeNames: [],\n    routes: [\n      {\n        key: 'UNKNOWN',\n        name: params.screen,\n        params: params.params,\n        path: params.path,\n      },\n    ],\n  };\n}\n\nfunction segmentMatchesConvention(segment: string): boolean {\n  return (\n    segment === 'index' ||\n    matchDynamicName(segment) != null ||\n    matchGroupName(segment) != null ||\n    matchDeepDynamicRouteName(segment) != null\n  );\n}\n\nfunction encodeURIComponentPreservingBrackets(str: string) {\n  return encodeURIComponent(str).replace(/%5B/g, '[').replace(/%5D/g, ']');\n}\n\n/**\n * Utility to serialize a navigation state object to a path string.\n *\n * @example\n * ```js\n * getPathFromState(\n *   {\n *     routes: [\n *       {\n *         name: 'Chat',\n *         params: { author: 'Jane', id: 42 },\n *       },\n *     ],\n *   },\n *   {\n *     screens: {\n *       Chat: {\n *         path: 'chat/:author/:id',\n *         stringify: { author: author => author.toLowerCase() }\n *       }\n *     }\n *   }\n * )\n * ```\n *\n * @param state Navigation state to serialize.\n * @param options Extra options to fine-tune how to serialize the path.\n * @returns Path representing the state, e.g. /foo/bar?count=42.\n */\nexport default function getPathFromState<ParamList extends object>(\n  state: State,\n  _options?: Options<ParamList> & {\n    preserveGroups?: boolean;\n    preserveDynamicRoutes?: boolean;\n  }\n): string {\n  return getPathDataFromState(state, _options).path;\n}\n\nexport function getPathDataFromState<ParamList extends object>(\n  state: State,\n  _options: Options<ParamList> & {\n    preserveGroups?: boolean;\n    preserveDynamicRoutes?: boolean;\n  } = { screens: DEFAULT_SCREENS }\n) {\n  if (state == null) {\n    throw Error(\"Got 'undefined' for the navigation state. You must pass a valid state object.\");\n  }\n\n  const { preserveGroups, preserveDynamicRoutes, ...options } = _options;\n\n  validatePathConfig(options);\n\n  // Expo Router disallows usage without a linking config.\n  if (Object.is(options.screens, DEFAULT_SCREENS)) {\n    throw Error(\"You must pass a 'screens' object to 'getPathFromState' to generate a path.\");\n  }\n\n  return getPathFromResolvedState(\n    JSON.parse(JSON.stringify(state)),\n    // Create a normalized configs object which will be easier to use\n    createNormalizedConfigs(options.screens),\n    { preserveGroups, preserveDynamicRoutes }\n  );\n}\n\nfunction processParamsWithUserSettings(configItem: ConfigItem, params: Record<string, any>) {\n  const stringify = configItem?.stringify;\n\n  return Object.fromEntries(\n    Object.entries(params).map(([key, value]) => [\n      key,\n      // TODO: Strip nullish values here.\n      stringify?.[key]\n        ? stringify[key](value)\n        : // Preserve rest params\n          Array.isArray(value)\n          ? value\n          : String(value),\n    ])\n  );\n}\n\nexport function deepEqual(a: any, b: any) {\n  if (a === b) {\n    return true;\n  }\n\n  if (Array.isArray(a) && Array.isArray(b)) {\n    if (a.length !== b.length) {\n      return false;\n    }\n\n    for (let i = 0; i < a.length; i++) {\n      if (!deepEqual(a[i], b[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  if (typeof a === 'object' && typeof b === 'object') {\n    const keysA = Object.keys(a);\n    const keysB = Object.keys(b);\n\n    if (keysA.length !== keysB.length) {\n      return false;\n    }\n\n    for (const key of keysA) {\n      if (!deepEqual(a[key], b[key])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  return false;\n}\n\nfunction walkConfigItems(\n  route: CustomRoute,\n  focusedRoute: {\n    name: string;\n    params?: object;\n  },\n  configs: Record<string, ConfigItem>,\n  {\n    preserveDynamicRoutes,\n  }: {\n    preserveDynamicRoutes?: boolean;\n  }\n) {\n  // NOTE(EvanBacon): Fill in current route using state that was passed as params.\n  if (!route.state && isInvalidParams(route.params)) {\n    route.state = createFakeState(route.params);\n  }\n\n  let pattern: string | null = null;\n  let focusedParams: Record<string, any> | undefined;\n  let hash: string | undefined;\n\n  const collectedParams: Record<string, any> = {};\n\n  while (route.name in configs) {\n    const configItem = configs[route.name];\n    const inputPattern = configItem.pattern;\n\n    if (inputPattern == null) {\n      // This should never happen in Expo Router.\n      throw new Error('Unexpected: No pattern found for route ' + route.name);\n    }\n    pattern = inputPattern;\n\n    if (route.params) {\n      if (route.params['#']) {\n        hash = route.params['#'];\n        delete route.params['#'];\n      }\n\n      const params = processParamsWithUserSettings(configItem, route.params);\n      if (pattern !== undefined && pattern !== null) {\n        Object.assign(collectedParams, params);\n      }\n      if (deepEqual(focusedRoute, route)) {\n        if (preserveDynamicRoutes) {\n          focusedParams = params;\n        } else {\n          // If this is the focused route, keep the params for later use\n          // We save it here since it's been stringified already\n          focusedParams = getParamsWithConventionsCollapsed({\n            params,\n            pattern,\n            routeName: route.name,\n          });\n        }\n      }\n    }\n\n    if (!route.state && isInvalidParams(route.params)) {\n      route.state = createFakeState(route.params);\n    }\n\n    // If there is no `screens` property or no nested state, we return pattern\n    if (!configItem.screens || route.state === undefined) {\n      if (\n        configItem.initialRouteName &&\n        configItem.screens &&\n        configItem.initialRouteName in configItem.screens &&\n        configItem.screens[configItem.initialRouteName]?.pattern\n      ) {\n        const initialRouteConfig = configItem.screens[configItem.initialRouteName];\n\n        // NOTE(EvanBacon): Big hack to support initial route changes in tab bars.\n        pattern = initialRouteConfig.pattern!;\n        if (focusedParams) {\n          if (!preserveDynamicRoutes) {\n            // If this is the focused route, keep the params for later use\n            // We save it here since it's been stringified already\n            focusedParams = getParamsWithConventionsCollapsed({\n              params: focusedParams,\n              pattern,\n              routeName: route.name,\n            });\n          }\n        }\n      }\n      break;\n    }\n\n    const index = route.state.index ?? route.state.routes.length - 1;\n\n    const nextRoute = route.state.routes[index];\n    const nestedScreens = configItem.screens;\n\n    // if there is config for next route name, we go deeper\n    if (nestedScreens && nextRoute.name in nestedScreens) {\n      route = nextRoute as CustomRoute;\n      configs = nestedScreens;\n    } else {\n      // If not, there is no sense in going deeper in config\n      break;\n    }\n  }\n\n  if (pattern == null) {\n    throw new Error(\n      `No pattern found for route \"${route.name}\". Options are: ${Object.keys(configs).join(', ')}.`\n    );\n  }\n\n  if (pattern && !focusedParams && focusedRoute.params) {\n    if (preserveDynamicRoutes) {\n      focusedParams = focusedRoute.params;\n    } else {\n      // If this is the focused route, keep the params for later use\n      // We save it here since it's been stringified already\n      focusedParams = getParamsWithConventionsCollapsed({\n        params: focusedRoute.params,\n        pattern,\n        routeName: route.name,\n      });\n    }\n    Object.assign(focusedParams, collectedParams);\n  }\n\n  return {\n    pattern,\n    nextRoute: route,\n    focusedParams,\n    hash,\n    params: collectedParams,\n  };\n}\n\nfunction getPathFromResolvedState(\n  state: State,\n  configs: Record<string, ConfigItem>,\n  {\n    preserveGroups,\n    preserveDynamicRoutes,\n  }: { preserveGroups?: boolean; preserveDynamicRoutes?: boolean }\n) {\n  let path = '';\n  let current: State = state;\n  let hash: string | undefined;\n\n  const allParams: Record<string, any> = {};\n\n  while (current) {\n    path += '/';\n\n    // Make mutable copies to ensure we don't leak state outside of the function.\n    const route = current.routes[current.index ?? 0] as CustomRoute;\n\n    // NOTE(EvanBacon): Fill in current route using state that was passed as params.\n    // if (isInvalidParams(route.params)) {\n    if (!route.state && isInvalidParams(route.params)) {\n      route.state = createFakeState(route.params);\n    }\n\n    const {\n      pattern,\n      params,\n      nextRoute,\n      focusedParams,\n      hash: $hash,\n    } = walkConfigItems(route, getActiveRoute(current), { ...configs }, { preserveDynamicRoutes });\n\n    if ($hash) {\n      hash = $hash;\n    }\n\n    Object.assign(allParams, params);\n\n    path += getPathWithConventionsCollapsed({\n      pattern,\n      routePath: nextRoute.path,\n      params: allParams,\n      initialRouteName: configs[nextRoute.name]?.initialRouteName,\n      preserveGroups,\n      preserveDynamicRoutes,\n    });\n\n    if (\n      nextRoute.state &&\n      // NOTE(EvanBacon): The upstream implementation allows for sending in synthetic states (states that weren't generated by `getStateFromPath`)\n      // and any invalid routes will simply be ignored.\n      // Because of this, we need to check if the next route is valid before continuing, otherwise our more strict\n      // implementation will throw an error.\n      configs[nextRoute.state.routes?.[nextRoute.state?.index ?? 0]?.name]\n    ) {\n      // Continue looping with the next state if available.\n      current = nextRoute.state;\n    } else {\n      // Finished crawling state.\n\n      // Check for query params before exiting.\n      if (focusedParams) {\n        for (const param in focusedParams) {\n          // TODO: This is not good. We shouldn't squat strings named \"undefined\".\n          if (focusedParams[param] === 'undefined') {\n            // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n            delete focusedParams[param];\n          }\n        }\n\n        const query = new URLSearchParams(focusedParams).toString();\n        if (query) {\n          path += `?${query}`;\n        }\n      }\n      break;\n    }\n  }\n\n  if (hash) {\n    allParams['#'] = hash;\n    path += `#${hash}`;\n  }\n\n  const params = decodeParams(allParams);\n\n  return { path: appendBaseUrl(basicSanitizePath(path)), params };\n}\n\nfunction decodeParams(params: Record<string, string>) {\n  const parsed: Record<string, any> = {};\n\n  for (const [key, value] of Object.entries(params)) {\n    try {\n      if (Array.isArray(value)) {\n        parsed[key] = value.map((v) => decodeURIComponent(v));\n      } else {\n        parsed[key] = decodeURIComponent(value);\n      }\n    } catch {\n      parsed[key] = value;\n    }\n  }\n\n  return parsed;\n}\n\nfunction getPathWithConventionsCollapsed({\n  pattern,\n  routePath,\n  params,\n  preserveGroups,\n  preserveDynamicRoutes,\n  initialRouteName,\n}: {\n  pattern: string;\n  routePath?: string;\n  params: Record<string, any>;\n  preserveGroups?: boolean;\n  preserveDynamicRoutes?: boolean;\n  initialRouteName?: string;\n}) {\n  const segments = pattern.split('/');\n  return segments\n    .map((p, i) => {\n      const name = getParamName(p);\n\n      // We don't know what to show for wildcard patterns\n      // Showing the route name seems ok, though whatever we show here will be incorrect\n      // Since the page doesn't actually exist\n      if (p.startsWith('*')) {\n        if (preserveDynamicRoutes) {\n          if (name === 'not-found') {\n            return '+not-found';\n          }\n          return `[...${name}]`;\n        }\n        if (params[name]) {\n          if (Array.isArray(params[name])) {\n            return params[name].join('/');\n          }\n          return params[name];\n        }\n        if (i === 0) {\n          // This can occur when a wildcard matches all routes and the given path was `/`.\n          return routePath;\n        }\n        // remove existing segments from route.path and return it\n        // this is used for nested wildcard routes. Without this, the path would add\n        // all nested segments to the beginning of the wildcard route.\n        return routePath\n          ?.split('/')\n          .slice(i + 1)\n          .join('/');\n      }\n\n      // If the path has a pattern for a param, put the param in the path\n      if (p.startsWith(':')) {\n        if (preserveDynamicRoutes) {\n          return `[${name}]`;\n        }\n        // Optional params without value assigned in route.params should be ignored\n        return params[name];\n      }\n\n      if (!preserveGroups && matchGroupName(p) != null) {\n        // When the last part is a group it could be a shared URL\n        // if the route has an initialRouteName defined, then we should\n        // use that as the component path as we can assume it will be shown.\n        if (segments.length - 1 === i) {\n          if (initialRouteName) {\n            // Return an empty string if the init route is ambiguous.\n            if (segmentMatchesConvention(initialRouteName)) {\n              return '';\n            }\n            return encodeURIComponentPreservingBrackets(initialRouteName);\n          }\n        }\n        return '';\n      }\n      // Preserve dynamic syntax for rehydration\n      return encodeURIComponentPreservingBrackets(p);\n    })\n    .map((v) => v ?? '')\n    .join('/');\n}\n\n/** Given a set of query params and a pattern with possible conventions, collapse the conventions and return the remaining params. */\nfunction getParamsWithConventionsCollapsed({\n  pattern,\n  routeName,\n  params,\n}: {\n  pattern: string;\n  /** Route name is required for matching the wildcard route. This is specific to Expo Router. */\n  routeName: string;\n  params: object;\n}): Record<string, string> {\n  const processedParams: Record<string, string> = { ...params };\n\n  // Remove the params present in the pattern since we'll only use the rest for query string\n\n  const segments = pattern.split('/');\n\n  // Dynamic Routes\n  segments\n    .filter((segment) => segment.startsWith(':'))\n    .forEach((segment) => {\n      const name = getParamName(segment);\n      delete processedParams[name];\n    });\n\n  // Deep Dynamic Routes\n  if (segments.some((segment) => segment.startsWith('*'))) {\n    // NOTE(EvanBacon): Drop the param name matching the wildcard route name -- this is specific to Expo Router.\n    const name = testNotFound(routeName)\n      ? 'not-found'\n      : matchDeepDynamicRouteName(routeName) ?? routeName;\n    delete processedParams[name];\n  }\n\n  return processedParams;\n}\n\n// Remove multiple as well as trailing slashes\nfunction basicSanitizePath(path: string) {\n  // Remove duplicate slashes like `foo//bar` -> `foo/bar`\n  const simplifiedPath = path.replace(/\\/+/g, '/');\n  if (simplifiedPath.length <= 1) {\n    return simplifiedPath;\n  }\n  // Remove trailing slash like `foo/bar/` -> `foo/bar`\n  return simplifiedPath.replace(/\\/$/, '');\n}\n\ntype StateAsParams = {\n  initial: boolean;\n  path?: string;\n  screen: string;\n  params: Record<string, any>;\n};\n\n// TODO: Make StackRouter not do this...\n// Detect if the params came from StackRouter using `params` to pass around internal state.\nfunction isInvalidParams(params?: Record<string, any>): params is StateAsParams {\n  if (!params) {\n    return false;\n  }\n\n  if ('params' in params && typeof params.params === 'object' && !!params.params) {\n    return true;\n  }\n\n  return (\n    'initial' in params &&\n    typeof params.initial === 'boolean' &&\n    // \"path\" in params &&\n    'screen' in params\n  );\n}\n\nconst getParamName = (pattern: string) => pattern.replace(/^[:*]/, '').replace(/\\?$/, '');\n\nconst joinPaths = (...paths: string[]): string =>\n  ([] as string[])\n    .concat(...paths.map((p) => p.split('/')))\n    .filter(Boolean)\n    .join('/');\n\nconst createConfigItem = (\n  config: PathConfig<object> | string,\n  parentPattern?: string\n): ConfigItem => {\n  if (typeof config === 'string') {\n    // If a string is specified as the value of the key(e.g. Foo: '/path'), use it as the pattern\n    const pattern = parentPattern ? joinPaths(parentPattern, config) : config;\n\n    return { pattern };\n  }\n\n  if (config.exact && config.path === undefined) {\n    throw new Error(\n      \"A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. `path: ''`.\"\n    );\n  }\n\n  // If an object is specified as the value (e.g. Foo: { ... }),\n  // It can have `path` property and `screens` prop which has nested configs\n  const pattern =\n    config.exact !== true ? joinPaths(parentPattern || '', config.path || '') : config.path || '';\n\n  const screens = config.screens ? createNormalizedConfigs(config.screens, pattern) : undefined;\n\n  return {\n    // Normalize pattern to remove any leading, trailing slashes, duplicate slashes etc.\n    pattern: pattern?.split('/').filter(Boolean).join('/'),\n    stringify: config.stringify,\n    screens,\n    initialRouteName: config.initialRouteName,\n  };\n};\n\nconst createNormalizedConfigs = (\n  options: PathConfigMap<object>,\n  pattern?: string\n): Record<string, ConfigItem> =>\n  Object.fromEntries(\n    Object.entries(options).map(([name, c]) => [name, createConfigItem(c, pattern)])\n  );\n\nexport function appendBaseUrl(\n  path: string,\n  baseUrl: string | undefined = process.env.EXPO_BASE_URL\n) {\n  if (process.env.NODE_ENV !== 'development') {\n    if (baseUrl) {\n      return `/${baseUrl.replace(/^\\/+/, '').replace(/\\/$/, '')}${path}`;\n    }\n  }\n  return path;\n}\n"],"mappings":"q9BAAA,MAAAA,MAAA,CAAAC,OAAA,2BAGA,MAAAC,UAAA,CAAAD,OAAA,gBA4BA,KAAM,CAAAE,eAAe,CAA0B,EAAE,CAEjD,KAAM,CAAAC,cAAc,CAAIC,KAAY,EAAuC,CACzE,KAAM,CAAAC,KAAK,CACT,MAAO,CAAAD,KAAK,CAACE,KAAK,GAAK,QAAQ,CAC3BF,KAAK,CAACG,MAAM,CAACH,KAAK,CAACE,KAAK,CAAC,CACzBF,KAAK,CAACG,MAAM,CAACH,KAAK,CAACG,MAAM,CAACC,MAAM,CAAG,CAAC,CAAC,CAE3C,GAAIH,KAAK,CAACD,KAAK,CAAE,CACf,MAAO,CAAAD,cAAc,CAACE,KAAK,CAACD,KAAK,CAAC,C,CAGpC,GAAIC,KAAK,EAAII,eAAe,CAACJ,KAAK,CAACK,MAAM,CAAC,CAAE,CAC1C,MAAO,CAAAP,cAAc,CAACQ,eAAe,CAACN,KAAK,CAACK,MAAM,CAAC,CAAC,C,CAGtD,MAAO,CAAAL,KAAK,CACd,CAAC,CAED,QAAS,CAAAM,eAAeA,CAACD,MAAqB,EAC5C,MAAO,CACLE,KAAK,CAAE,KAAK,CACZC,IAAI,CAAE,SAAS,CACfC,GAAG,CAAE,SAAS,CACdR,KAAK,CAAE,CAAC,CACRS,UAAU,CAAE,EAAE,CACdR,MAAM,CAAE,CACN,CACEO,GAAG,CAAE,SAAS,CACdE,IAAI,CAAEN,MAAM,CAACO,MAAM,CACnBP,MAAM,CAAEA,MAAM,CAACA,MAAM,CACrBQ,IAAI,CAAER,MAAM,CAACQ,I,CACd,C,CAEJ,CACH,CAEA,QAAS,CAAAC,wBAAwBA,CAACC,OAAe,EAC/C,MACE,CAAAA,OAAO,GAAK,OAAO,EACnB,GAAAnB,UAAA,CAAAoB,gBAAgB,EAACD,OAAO,CAAC,EAAI,IAAI,EACjC,GAAAnB,UAAA,CAAAqB,cAAc,EAACF,OAAO,CAAC,EAAI,IAAI,EAC/B,GAAAnB,UAAA,CAAAsB,yBAAyB,EAACH,OAAO,CAAC,EAAI,IAAI,CAE9C,CAEA,QAAS,CAAAI,oCAAoCA,CAACC,GAAW,EACvD,MAAO,CAAAC,kBAAkB,CAACD,GAAG,CAAC,CAACE,OAAO,CAAC,MAAM,CAAE,GAAG,CAAC,CAACA,OAAO,CAAC,MAAM,CAAE,GAAG,CAAC,CAC1E,CA+BA,QAAwB,CAAAC,gBAAgBA,CACtCxB,KAAY,CACZyB,QAGC,EAED,MAAO,CAAAC,oBAAoB,CAAC1B,KAAK,CAAEyB,QAAQ,CAAC,CAACX,IAAI,CACnD,CARAa,OAAA,CAAAC,OAAA,CAAAJ,gBAAA,CAUA,QAAgB,CAAAE,oBAAoBA,CAClC1B,KAAY,CACZyB,QAAA,CAGI,CAAEI,OAAO,CAAE/B,eAAe,CAAE,EAEhC,GAAIE,KAAK,EAAI,IAAI,CAAE,CACjB,KAAM,CAAA8B,KAAK,CAAC,+EAA+E,CAAC,C,CAG9F,KAAM,CAAEC,cAAc,CAAEC,qBAAiC,CAAE,CAAGP,QAAQ,CAApBQ,OAAO,CAAAC,wBAAA,CAAKT,QAAQ,CAAAU,SAAA,EAEtE,GAAAxC,MAAA,CAAAyC,kBAAkB,EAACH,OAAO,CAAC,CAG3B,GAAII,MAAM,CAACC,EAAE,CAACL,OAAO,CAACJ,OAAO,CAAE/B,eAAe,CAAC,CAAE,CAC/C,KAAM,CAAAgC,KAAK,CAAC,4EAA4E,CAAC,C,CAG3F,MAAO,CAAAS,wBAAwB,CAC7BC,IAAI,CAACC,KAAK,CAACD,IAAI,CAACE,SAAS,CAAC1C,KAAK,CAAC,CAAC,CAEjC2C,uBAAuB,CAACV,OAAO,CAACJ,OAAO,CAAC,CACxC,CAAEE,cAAc,CAAEC,qBAAqB,CAAE,CAC1C,CACH,CA1BAL,OAAA,CAAAD,oBAAA,CAAAA,oBAAA,CA4BA,QAAS,CAAAkB,6BAA6BA,CAACC,UAAsB,CAAEvC,MAA2B,EACxF,KAAM,CAAAoC,SAAS,CAAGG,UAAU,EAAEH,SAAS,CAEvC,MAAO,CAAAL,MAAM,CAACS,WAAW,CACvBT,MAAM,CAACU,OAAO,CAACzC,MAAM,CAAC,CAAC0C,GAAG,CAAC,CAAC,CAACtC,GAAG,CAAEuC,KAAK,CAAC,GAAK,CAC3CvC,GAAG,CAEHgC,SAAS,GAAGhC,GAAG,CAAC,CACZgC,SAAS,CAAChC,GAAG,CAAC,CAACuC,KAAK,CAAC,CAErBC,KAAK,CAACC,OAAO,CAACF,KAAK,CAAC,CAClBA,KAAK,CACLG,MAAM,CAACH,KAAK,CAAC,CACpB,CAAC,CACH,CACH,CAEA,QAAgB,CAAAI,SAASA,CAACC,CAAM,CAAEC,CAAM,EACtC,GAAID,CAAC,GAAKC,CAAC,CAAE,CACX,MAAO,KAAI,C,CAGb,GAAIL,KAAK,CAACC,OAAO,CAACG,CAAC,CAAC,EAAIJ,KAAK,CAACC,OAAO,CAACI,CAAC,CAAC,CAAE,CACxC,GAAID,CAAC,CAAClD,MAAM,GAAKmD,CAAC,CAACnD,MAAM,CAAE,CACzB,MAAO,MAAK,C,CAGd,IAAK,GAAI,CAAAoD,CAAC,CAAG,CAAC,CAAEA,CAAC,CAAGF,CAAC,CAAClD,MAAM,CAAEoD,CAAC,EAAE,CAAE,CACjC,GAAI,CAACH,SAAS,CAACC,CAAC,CAACE,CAAC,CAAC,CAAED,CAAC,CAACC,CAAC,CAAC,CAAC,CAAE,CAC1B,MAAO,MAAK,C,EAIhB,MAAO,KAAI,C,CAGb,GAAI,MAAO,CAAAF,CAAC,GAAK,QAAQ,EAAI,MAAO,CAAAC,CAAC,GAAK,QAAQ,CAAE,CAClD,KAAM,CAAAE,KAAK,CAAGpB,MAAM,CAACqB,IAAI,CAACJ,CAAC,CAAC,CAC5B,KAAM,CAAAK,KAAK,CAAGtB,MAAM,CAACqB,IAAI,CAACH,CAAC,CAAC,CAE5B,GAAIE,KAAK,CAACrD,MAAM,GAAKuD,KAAK,CAACvD,MAAM,CAAE,CACjC,MAAO,MAAK,C,CAGd,IAAK,KAAM,CAAAM,GAAG,GAAI,CAAA+C,KAAK,CAAE,CACvB,GAAI,CAACJ,SAAS,CAACC,CAAC,CAAC5C,GAAG,CAAC,CAAE6C,CAAC,CAAC7C,GAAG,CAAC,CAAC,CAAE,CAC9B,MAAO,MAAK,C,EAIhB,MAAO,KAAI,C,CAGb,MAAO,MAAK,CACd,CArCAiB,OAAA,CAAA0B,SAAA,CAAAA,SAAA,CAuCA,QAAS,CAAAO,eAAeA,CACtB3D,KAAkB,CAClB4D,YAGC,CACDC,OAAmC,CACnC,CACE9B,qBAAqB,CAGtB,EAGD,GAAI,CAAC/B,KAAK,CAACD,KAAK,EAAIK,eAAe,CAACJ,KAAK,CAACK,MAAM,CAAC,CAAE,CACjDL,KAAK,CAACD,KAAK,CAAGO,eAAe,CAACN,KAAK,CAACK,MAAM,CAAC,C,CAG7C,GAAI,CAAAyD,OAAO,CAAkB,IAAI,CACjC,GAAI,CAAAC,aAA8C,CAClD,GAAI,CAAAC,IAAwB,CAE5B,KAAM,CAAAC,eAAe,CAAwB,EAAE,CAE/C,MAAOjE,KAAK,CAACW,IAAI,GAAI,CAAAkD,OAAO,CAAE,CAC5B,KAAM,CAAAjB,UAAU,CAAGiB,OAAO,CAAC7D,KAAK,CAACW,IAAI,CAAC,CACtC,KAAM,CAAAuD,YAAY,CAAGtB,UAAU,CAACkB,OAAO,CAEvC,GAAII,YAAY,EAAI,IAAI,CAAE,CAExB,KAAM,IAAI,CAAArC,KAAK,CAAC,yCAAyC,CAAG7B,KAAK,CAACW,IAAI,CAAC,C,CAEzEmD,OAAO,CAAGI,YAAY,CAEtB,GAAIlE,KAAK,CAACK,MAAM,CAAE,CAChB,GAAIL,KAAK,CAACK,MAAM,CAAC,GAAG,CAAC,CAAE,CACrB2D,IAAI,CAAGhE,KAAK,CAACK,MAAM,CAAC,GAAG,CAAC,CACxB,MAAO,CAAAL,KAAK,CAACK,MAAM,CAAC,GAAG,CAAC,C,CAG1B,KAAM,CAAAA,MAAM,CAAGsC,6BAA6B,CAACC,UAAU,CAAE5C,KAAK,CAACK,MAAM,CAAC,CACtE,GAAIyD,OAAO,GAAKK,SAAS,EAAIL,OAAO,GAAK,IAAI,CAAE,CAC7C1B,MAAM,CAACgC,MAAM,CAACH,eAAe,CAAE5D,MAAM,CAAC,C,CAExC,GAAI+C,SAAS,CAACQ,YAAY,CAAE5D,KAAK,CAAC,CAAE,CAClC,GAAI+B,qBAAqB,CAAE,CACzBgC,aAAa,CAAG1D,MAAM,C,CACvB,IAAM,CAGL0D,aAAa,CAAGM,iCAAiC,CAAC,CAChDhE,MAAM,CACNyD,OAAO,CACPQ,SAAS,CAAEtE,KAAK,CAACW,I,CAClB,CAAC,C,GAKR,GAAI,CAACX,KAAK,CAACD,KAAK,EAAIK,eAAe,CAACJ,KAAK,CAACK,MAAM,CAAC,CAAE,CACjDL,KAAK,CAACD,KAAK,CAAGO,eAAe,CAACN,KAAK,CAACK,MAAM,CAAC,C,CAI7C,GAAI,CAACuC,UAAU,CAAChB,OAAO,EAAI5B,KAAK,CAACD,KAAK,GAAKoE,SAAS,CAAE,CACpD,GACEvB,UAAU,CAAC2B,gBAAgB,EAC3B3B,UAAU,CAAChB,OAAO,EAClBgB,UAAU,CAAC2B,gBAAgB,GAAI,CAAA3B,UAAU,CAAChB,OAAO,EACjDgB,UAAU,CAAChB,OAAO,CAACgB,UAAU,CAAC2B,gBAAgB,CAAC,EAAET,OAAO,CACxD,CACA,KAAM,CAAAU,kBAAkB,CAAG5B,UAAU,CAAChB,OAAO,CAACgB,UAAU,CAAC2B,gBAAgB,CAAC,CAG1ET,OAAO,CAAGU,kBAAkB,CAACV,OAAQ,CACrC,GAAIC,aAAa,CAAE,CACjB,GAAI,CAAChC,qBAAqB,CAAE,CAG1BgC,aAAa,CAAGM,iCAAiC,CAAC,CAChDhE,MAAM,CAAE0D,aAAa,CACrBD,OAAO,CACPQ,SAAS,CAAEtE,KAAK,CAACW,I,CAClB,CAAC,C,GAIR,M,CAGF,KAAM,CAAAV,KAAK,CAAGD,KAAK,CAACD,KAAK,CAACE,KAAK,EAAID,KAAK,CAACD,KAAK,CAACG,MAAM,CAACC,MAAM,CAAG,CAAC,CAEhE,KAAM,CAAAsE,SAAS,CAAGzE,KAAK,CAACD,KAAK,CAACG,MAAM,CAACD,KAAK,CAAC,CAC3C,KAAM,CAAAyE,aAAa,CAAG9B,UAAU,CAAChB,OAAO,CAGxC,GAAI8C,aAAa,EAAID,SAAS,CAAC9D,IAAI,GAAI,CAAA+D,aAAa,CAAE,CACpD1E,KAAK,CAAGyE,SAAwB,CAChCZ,OAAO,CAAGa,aAAa,C,CACxB,IAAM,CAEL,M,EAIJ,GAAIZ,OAAO,EAAI,IAAI,CAAE,CACnB,KAAM,IAAI,CAAAjC,KAAK,CACb,+BAA+B7B,KAAK,CAACW,IAAI,mBAAmByB,MAAM,CAACqB,IAAI,CAACI,OAAO,CAAC,CAACc,IAAI,CAAC,IAAI,CAAC,GAAG,CAC/F,C,CAGH,GAAIb,OAAO,EAAI,CAACC,aAAa,EAAIH,YAAY,CAACvD,MAAM,CAAE,CACpD,GAAI0B,qBAAqB,CAAE,CACzBgC,aAAa,CAAGH,YAAY,CAACvD,MAAM,C,CACpC,IAAM,CAGL0D,aAAa,CAAGM,iCAAiC,CAAC,CAChDhE,MAAM,CAAEuD,YAAY,CAACvD,MAAM,CAC3ByD,OAAO,CACPQ,SAAS,CAAEtE,KAAK,CAACW,I,CAClB,CAAC,C,CAEJyB,MAAM,CAACgC,MAAM,CAACL,aAAa,CAAEE,eAAe,CAAC,C,CAG/C,MAAO,CACLH,OAAO,CACPW,SAAS,CAAEzE,KAAK,CAChB+D,aAAa,CACbC,IAAI,CACJ3D,MAAM,CAAE4D,e,CACT,CACH,CAEA,QAAS,CAAA3B,wBAAwBA,CAC/BvC,KAAY,CACZ8D,OAAmC,CACnC,CACE/B,cAAc,CACdC,qBAAqB,CACyC,EAEhE,GAAI,CAAAlB,IAAI,CAAG,EAAE,CACb,GAAI,CAAA+D,OAAO,CAAU7E,KAAK,CAC1B,GAAI,CAAAiE,IAAwB,CAE5B,KAAM,CAAAa,SAAS,CAAwB,EAAE,CAEzC,MAAOD,OAAO,CAAE,CACd/D,IAAI,EAAI,GAAG,CAGX,KAAM,CAAAb,KAAK,CAAG4E,OAAO,CAAC1E,MAAM,CAAC0E,OAAO,CAAC3E,KAAK,EAAI,CAAC,CAAgB,CAI/D,GAAI,CAACD,KAAK,CAACD,KAAK,EAAIK,eAAe,CAACJ,KAAK,CAACK,MAAM,CAAC,CAAE,CACjDL,KAAK,CAACD,KAAK,CAAGO,eAAe,CAACN,KAAK,CAACK,MAAM,CAAC,C,CAG7C,KAAM,CACJyD,OAAO,CACPzD,MAAM,CACNoE,SAAS,CACTV,aAAa,CACbC,IAAI,CAAEc,KAAK,CACZ,CAAGnB,eAAe,CAAC3D,KAAK,CAAEF,cAAc,CAAC8E,OAAO,CAAC,CAAAG,aAAA,IAAOlB,OAAO,EAAI,CAAE9B,qBAAqB,CAAE,CAAC,CAE9F,GAAI+C,KAAK,CAAE,CACTd,IAAI,CAAGc,KAAK,C,CAGd1C,MAAM,CAACgC,MAAM,CAACS,SAAS,CAAExE,MAAM,CAAC,CAEhCQ,IAAI,EAAImE,+BAA+B,CAAC,CACtClB,OAAO,CACPmB,SAAS,CAAER,SAAS,CAAC5D,IAAI,CACzBR,MAAM,CAAEwE,SAAS,CACjBN,gBAAgB,CAAEV,OAAO,CAACY,SAAS,CAAC9D,IAAI,CAAC,EAAE4D,gBAAgB,CAC3DzC,cAAc,CACdC,qB,CACD,CAAC,CAEF,GACE0C,SAAS,CAAC1E,KAAK,EAKf8D,OAAO,CAACY,SAAS,CAAC1E,KAAK,CAACG,MAAM,GAAGuE,SAAS,CAAC1E,KAAK,EAAEE,KAAK,EAAI,CAAC,CAAC,EAAEU,IAAI,CAAC,CACpE,CAEAiE,OAAO,CAAGH,SAAS,CAAC1E,KAAK,C,CAC1B,IAAM,CAIL,GAAIgE,aAAa,CAAE,CACjB,IAAK,KAAM,CAAAmB,KAAK,GAAI,CAAAnB,aAAa,CAAE,CAEjC,GAAIA,aAAa,CAACmB,KAAK,CAAC,GAAK,WAAW,CAAE,CAExC,MAAO,CAAAnB,aAAa,CAACmB,KAAK,CAAC,C,EAI/B,KAAM,CAAAC,KAAK,CAAG,GAAI,CAAAC,eAAe,CAACrB,aAAa,CAAC,CAACsB,QAAQ,EAAE,CAC3D,GAAIF,KAAK,CAAE,CACTtE,IAAI,EAAI,IAAIsE,KAAK,EAAE,C,EAGvB,M,EAIJ,GAAInB,IAAI,CAAE,CACRa,SAAS,CAAC,GAAG,CAAC,CAAGb,IAAI,CACrBnD,IAAI,EAAI,IAAImD,IAAI,EAAE,C,CAGpB,KAAM,CAAA3D,MAAM,CAAGiF,YAAY,CAACT,SAAS,CAAC,CAEtC,MAAO,CAAEhE,IAAI,CAAE0E,aAAa,CAACC,iBAAiB,CAAC3E,IAAI,CAAC,CAAC,CAAER,MAAM,CAAE,CACjE,CAEA,QAAS,CAAAiF,YAAYA,CAACjF,MAA8B,EAClD,KAAM,CAAAoF,MAAM,CAAwB,EAAE,CAEtC,IAAK,KAAM,CAAChF,GAAG,CAAEuC,KAAK,CAAC,EAAI,CAAAZ,MAAM,CAACU,OAAO,CAACzC,MAAM,CAAC,CAAE,CACjD,GAAI,CACF,GAAI4C,KAAK,CAACC,OAAO,CAACF,KAAK,CAAC,CAAE,CACxByC,MAAM,CAAChF,GAAG,CAAC,CAAGuC,KAAK,CAACD,GAAG,CAAE2C,CAAC,EAAKC,kBAAkB,CAACD,CAAC,CAAC,CAAC,C,CACtD,IAAM,CACLD,MAAM,CAAChF,GAAG,CAAC,CAAGkF,kBAAkB,CAAC3C,KAAK,CAAC,C,EAEzC,KAAM,CACNyC,MAAM,CAAChF,GAAG,CAAC,CAAGuC,KAAK,C,EAIvB,MAAO,CAAAyC,MAAM,CACf,CAEA,QAAS,CAAAT,+BAA+BA,CAAC,CACvClB,OAAO,CACPmB,SAAS,CACT5E,MAAM,CACNyB,cAAc,CACdC,qBAAqB,CACrBwC,gBAAgB,CAQjB,EACC,KAAM,CAAAqB,QAAQ,CAAG9B,OAAO,CAAC+B,KAAK,CAAC,GAAG,CAAC,CACnC,MAAO,CAAAD,QAAQ,CACZ7C,GAAG,CAAC,CAAC+C,CAAC,CAAEvC,CAAC,GAAI,CACZ,KAAM,CAAA5C,IAAI,CAAGoF,YAAY,CAACD,CAAC,CAAC,CAK5B,GAAIA,CAAC,CAACE,UAAU,CAAC,GAAG,CAAC,CAAE,CACrB,GAAIjE,qBAAqB,CAAE,CACzB,GAAIpB,IAAI,GAAK,WAAW,CAAE,CACxB,MAAO,YAAY,C,CAErB,MAAO,OAAOA,IAAI,GAAG,C,CAEvB,GAAIN,MAAM,CAACM,IAAI,CAAC,CAAE,CAChB,GAAIsC,KAAK,CAACC,OAAO,CAAC7C,MAAM,CAACM,IAAI,CAAC,CAAC,CAAE,CAC/B,MAAO,CAAAN,MAAM,CAACM,IAAI,CAAC,CAACgE,IAAI,CAAC,GAAG,CAAC,C,CAE/B,MAAO,CAAAtE,MAAM,CAACM,IAAI,CAAC,C,CAErB,GAAI4C,CAAC,GAAK,CAAC,CAAE,CAEX,MAAO,CAAA0B,SAAS,C,CAKlB,MAAO,CAAAA,SAAS,EACZY,KAAK,CAAC,GAAG,CAAC,CACXI,KAAK,CAAC1C,CAAC,CAAG,CAAC,CAAC,CACZoB,IAAI,CAAC,GAAG,CAAC,C,CAId,GAAImB,CAAC,CAACE,UAAU,CAAC,GAAG,CAAC,CAAE,CACrB,GAAIjE,qBAAqB,CAAE,CACzB,MAAO,IAAIpB,IAAI,GAAG,C,CAGpB,MAAO,CAAAN,MAAM,CAACM,IAAI,CAAC,C,CAGrB,GAAI,CAACmB,cAAc,EAAI,GAAAlC,UAAA,CAAAqB,cAAc,EAAC6E,CAAC,CAAC,EAAI,IAAI,CAAE,CAIhD,GAAIF,QAAQ,CAACzF,MAAM,CAAG,CAAC,GAAKoD,CAAC,CAAE,CAC7B,GAAIgB,gBAAgB,CAAE,CAEpB,GAAIzD,wBAAwB,CAACyD,gBAAgB,CAAC,CAAE,CAC9C,MAAO,EAAE,C,CAEX,MAAO,CAAApD,oCAAoC,CAACoD,gBAAgB,CAAC,C,EAGjE,MAAO,EAAE,C,CAGX,MAAO,CAAApD,oCAAoC,CAAC2E,CAAC,CAAC,CAChD,CAAC,CAAC,CACD/C,GAAG,CAAE2C,CAAC,EAAKA,CAAC,EAAI,EAAE,CAAC,CACnBf,IAAI,CAAC,GAAG,CAAC,CACd,CAGA,QAAS,CAAAN,iCAAiCA,CAAC,CACzCP,OAAO,CACPQ,SAAS,CACTjE,MAAM,CAMP,EACC,KAAM,CAAA6F,eAAe,CAAAnB,aAAA,IAAgC1E,MAAM,CAAE,CAI7D,KAAM,CAAAuF,QAAQ,CAAG9B,OAAO,CAAC+B,KAAK,CAAC,GAAG,CAAC,CAGnCD,QAAQ,CACLO,MAAM,CAAEpF,OAAO,EAAKA,OAAO,CAACiF,UAAU,CAAC,GAAG,CAAC,CAAC,CAC5CI,OAAO,CAAErF,OAAO,EAAI,CACnB,KAAM,CAAAJ,IAAI,CAAGoF,YAAY,CAAChF,OAAO,CAAC,CAClC,MAAO,CAAAmF,eAAe,CAACvF,IAAI,CAAC,CAC9B,CAAC,CAAC,CAGJ,GAAIiF,QAAQ,CAACS,IAAI,CAAEtF,OAAO,EAAKA,OAAO,CAACiF,UAAU,CAAC,GAAG,CAAC,CAAC,CAAE,CAEvD,KAAM,CAAArF,IAAI,CAAG,GAAAf,UAAA,CAAA0G,YAAY,EAAChC,SAAS,CAAC,CAChC,WAAW,CACX,GAAA1E,UAAA,CAAAsB,yBAAyB,EAACoD,SAAS,CAAC,EAAIA,SAAS,CACrD,MAAO,CAAA4B,eAAe,CAACvF,IAAI,CAAC,C,CAG9B,MAAO,CAAAuF,eAAe,CACxB,CAGA,QAAS,CAAAV,iBAAiBA,CAAC3E,IAAY,EAErC,KAAM,CAAA0F,cAAc,CAAG1F,IAAI,CAACS,OAAO,CAAC,MAAM,CAAE,GAAG,CAAC,CAChD,GAAIiF,cAAc,CAACpG,MAAM,EAAI,CAAC,CAAE,CAC9B,MAAO,CAAAoG,cAAc,C,CAGvB,MAAO,CAAAA,cAAc,CAACjF,OAAO,CAAC,KAAK,CAAE,EAAE,CAAC,CAC1C,CAWA,QAAS,CAAAlB,eAAeA,CAACC,MAA4B,EACnD,GAAI,CAACA,MAAM,CAAE,CACX,MAAO,MAAK,C,CAGd,GAAI,QAAQ,EAAI,CAAAA,MAAM,EAAI,MAAO,CAAAA,MAAM,CAACA,MAAM,GAAK,QAAQ,EAAI,CAAC,CAACA,MAAM,CAACA,MAAM,CAAE,CAC9E,MAAO,KAAI,C,CAGb,MACE,SAAS,EAAI,CAAAA,MAAM,EACnB,MAAO,CAAAA,MAAM,CAACmG,OAAO,GAAK,SAAS,EAEnC,QAAQ,EAAI,CAAAnG,MAAM,CAEtB,CAEA,KAAM,CAAA0F,YAAY,CAAIjC,OAAe,EAAKA,OAAO,CAACxC,OAAO,CAAC,OAAO,CAAE,EAAE,CAAC,CAACA,OAAO,CAAC,KAAK,CAAE,EAAE,CAAC,CAEzF,KAAM,CAAAmF,SAAS,CAAGA,CAAC,GAAGC,KAAe,GAClC,EAAe,CACbC,MAAM,CAAC,GAAGD,KAAK,CAAC3D,GAAG,CAAE+C,CAAC,EAAKA,CAAC,CAACD,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CACzCM,MAAM,CAACS,OAAO,CAAC,CACfjC,IAAI,CAAC,GAAG,CAAC,CAEd,KAAM,CAAAkC,gBAAgB,CAAGA,CACvBC,MAAmC,CACnCC,aAAsB,GACR,CACd,GAAI,MAAO,CAAAD,MAAM,GAAK,QAAQ,CAAE,CAE9B,KAAM,CAAAhD,OAAO,CAAGiD,aAAa,CAAGN,SAAS,CAACM,aAAa,CAAED,MAAM,CAAC,CAAGA,MAAM,CAEzE,MAAO,CAAEhD,OAAO,CAAE,C,CAGpB,GAAIgD,MAAM,CAACE,KAAK,EAAIF,MAAM,CAACjG,IAAI,GAAKsD,SAAS,CAAE,CAC7C,KAAM,IAAI,CAAAtC,KAAK,CACb,sJAAsJ,CACvJ,C,CAKH,KAAM,CAAAiC,OAAO,CACXgD,MAAM,CAACE,KAAK,GAAK,IAAI,CAAGP,SAAS,CAACM,aAAa,EAAI,EAAE,CAAED,MAAM,CAACjG,IAAI,EAAI,EAAE,CAAC,CAAGiG,MAAM,CAACjG,IAAI,EAAI,EAAE,CAE/F,KAAM,CAAAe,OAAO,CAAGkF,MAAM,CAAClF,OAAO,CAAGc,uBAAuB,CAACoE,MAAM,CAAClF,OAAO,CAAEkC,OAAO,CAAC,CAAGK,SAAS,CAE7F,MAAO,CAELL,OAAO,CAAEA,OAAO,EAAE+B,KAAK,CAAC,GAAG,CAAC,CAACM,MAAM,CAACS,OAAO,CAAC,CAACjC,IAAI,CAAC,GAAG,CAAC,CACtDlC,SAAS,CAAEqE,MAAM,CAACrE,SAAS,CAC3Bb,OAAO,CACP2C,gBAAgB,CAAEuC,MAAM,CAACvC,gB,CAC1B,CACH,CAAC,CAED,KAAM,CAAA7B,uBAAuB,CAAGA,CAC9BV,OAA8B,CAC9B8B,OAAgB,GAEhB1B,MAAM,CAACS,WAAW,CAChBT,MAAM,CAACU,OAAO,CAACd,OAAO,CAAC,CAACe,GAAG,CAAC,CAAC,CAACpC,IAAI,CAAEsG,CAAC,CAAC,GAAK,CAACtG,IAAI,CAAEkG,gBAAgB,CAACI,CAAC,CAAEnD,OAAO,CAAC,CAAC,CAAC,CACjF,CAEH,QAAgB,CAAAyB,aAAaA,CAC3B1E,IAAY,CACZqG,OAAA,GAAuD,EAEvD,QAA4C,CAC1C,GAAIA,OAAO,CAAE,CACX,MAAO,IAAIA,OAAO,CAAC5F,OAAO,CAAC,MAAM,CAAE,EAAE,CAAC,CAACA,OAAO,CAAC,KAAK,CAAE,EAAE,CAAC,GAAGT,IAAI,EAAE,C,EAGtE,MAAO,CAAAA,IAAI,CACb,CAVAa,OAAA,CAAA6D,aAAA,CAAAA,aAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}