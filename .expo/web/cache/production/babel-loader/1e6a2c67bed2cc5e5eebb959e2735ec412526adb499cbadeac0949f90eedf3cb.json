{"ast":null,"code":"\"use strict\";var _defineProperty=require(\"@babel/runtime/helpers/defineProperty\");function ownKeys(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);r&&(o=o.filter(function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable;})),t.push.apply(t,o);}return t;}function _objectSpread(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?ownKeys(Object(t),!0).forEach(function(r){_defineProperty(e,r,t[r]);}):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):ownKeys(Object(t)).forEach(function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r));});}return e;}var __importDefault=this&&this.__importDefault||function(mod){return mod&&mod.__esModule?mod:{\"default\":mod};};Object.defineProperty(exports,\"__esModule\",{value:true});exports.stripBaseUrl=exports.getMatchableRouteConfigs=exports.getUrlWithReactNavigationConcessions=void 0;const escape_string_regexp_1=__importDefault(require(\"escape-string-regexp\"));const findFocusedRoute_1=require(\"./findFocusedRoute\");const validatePathConfig_1=__importDefault(require(\"./validatePathConfig\"));const matchers_1=require(\"../matchers\");function getUrlWithReactNavigationConcessions(path,baseUrl=\"\"){let parsed;try{parsed=new URL(path,'https://phony.example');}catch{return{nonstandardPathname:'',inputPathnameWithoutHash:'',url:null};}const pathname=parsed.pathname;return{nonstandardPathname:stripBaseUrl(pathname,baseUrl).replace(/^\\/+/g,'').replace(/\\/+$/g,'')+'/',url:parsed};}exports.getUrlWithReactNavigationConcessions=getUrlWithReactNavigationConcessions;function getStateFromPath(path,options){const{initialRoutes,configs}=getMatchableRouteConfigs(options);return getStateFromPathWithConfigs(path,configs,initialRoutes);}exports.default=getStateFromPath;function getMatchableRouteConfigs(options){if(options){(0,validatePathConfig_1.default)(options);}const screens=options?.screens;if(!screens){throw Error(\"You must pass a 'screens' object to 'getStateFromPath' to generate a path.\");}const initialRoutes=[];if(options?.initialRouteName){initialRoutes.push({initialRouteName:options.initialRouteName,parentScreens:[]});}const converted=Object.keys(screens).map(key=>createNormalizedConfigs(key,screens,[],initialRoutes)).flat();const resolvedInitialPatterns=initialRoutes.map(route=>joinPaths(...route.parentScreens,route.initialRouteName));const convertedWithInitial=converted.map(config=>_objectSpread(_objectSpread({},config),{},{isInitial:resolvedInitialPatterns.includes(config.routeNames.join('/'))}));const configs=convertedWithInitial.sort(sortConfigs);assertConfigDuplicates(configs);return{configs,initialRoutes};}exports.getMatchableRouteConfigs=getMatchableRouteConfigs;function assertConfigDuplicates(configs){configs.reduce((acc,config)=>{const indexedKey=config.regex?.toString()??config.pattern;const alpha=acc[indexedKey];if(alpha&&!alpha.hasChildren&&!config.hasChildren){const a=alpha.routeNames;const b=config.routeNames;const intersects=a.length>b.length?b.every((it,i)=>a[i]===it):a.every((it,i)=>b[i]===it);if(!intersects){const last=config.pattern.split('/').pop();if(!last?.match(/^\\*not-found$/)){const routeType=last?.startsWith(':')?'dynamic route':last?.startsWith('*')?'dynamic-rest route':'route';throw new Error(`The ${routeType} pattern '${config.pattern||'/'}' resolves to both '${alpha.userReadableName}' and '${config.userReadableName}'. Patterns must be unique and cannot resolve to more than one route.`);}}}return Object.assign(acc,{[indexedKey]:config});},{});}function sortConfigs(a,b){if(a.pattern===b.pattern){return b.routeNames.join('>').localeCompare(a.routeNames.join('>'));}if(a.pattern.startsWith(b.pattern)&&b.screen!=='index'){return-1;}if(b.pattern.startsWith(a.pattern)&&a.screen!=='index'){return 1;}const aParts=a.pattern.split('/').filter(part=>(0,matchers_1.matchGroupName)(part)==null);if(a.screen==='index'||a.screen.match(/\\/index$/)){aParts.push('index');}const bParts=b.pattern.split('/').filter(part=>(0,matchers_1.matchGroupName)(part)==null);if(b.screen==='index'||b.screen.match(/\\/index$/)){bParts.push('index');}for(let i=0;i<Math.max(aParts.length,bParts.length);i++){if(aParts[i]==null){return 1;}if(bParts[i]==null){return-1;}const aWildCard=aParts[i].startsWith('*');const bWildCard=bParts[i].startsWith('*');if(aWildCard&&bWildCard){const aNotFound=aParts[i].match(/^[*]not-found$/);const bNotFound=bParts[i].match(/^[*]not-found$/);if(aNotFound&&bNotFound){continue;}else if(aNotFound){return 1;}else if(bNotFound){return-1;}continue;}if(aWildCard){return 1;}if(bWildCard){return-1;}const aSlug=aParts[i].startsWith(':');const bSlug=bParts[i].startsWith(':');if(aSlug&&bSlug){const aNotFound=aParts[i].match(/^[*]not-found$/);const bNotFound=bParts[i].match(/^[*]not-found$/);if(aNotFound&&bNotFound){continue;}else if(aNotFound){return 1;}else if(bNotFound){return-1;}continue;}if(aSlug){return 1;}if(bSlug){return-1;}}if(a.isInitial&&!b.isInitial){return-1;}if(!a.isInitial&&b.isInitial){return 1;}return bParts.length-aParts.length;}function getStateFromEmptyPathWithConfigs(path,hash,configs,initialRoutes){const leafNodes=configs.filter(config=>!config.hasChildren).map(value=>{return _objectSpread(_objectSpread({},value),{},{path:(0,matchers_1.stripGroupSegmentsFromPath)(value.path)});});const match=leafNodes.find(config=>config.path===''&&(!config.regex||config.regex.test('')))??leafNodes.find(config=>config.path.startsWith(':')&&config.regex.test(''))??leafNodes.find(config=>config.path.startsWith('*')&&config.regex.test('/'));if(!match){return undefined;}const routes=match.routeNames.map(name=>{if(!match._route){return{name};}return{name,_route:match._route};});return createNestedStateObject(path,hash,routes,configs,initialRoutes);}function getStateFromPathWithConfigs(path,configs,initialRoutes,baseUrl=\"\"){const formattedPaths=getUrlWithReactNavigationConcessions(path);if(!formattedPaths.url)return;let cleanPath=stripBaseUrl((0,matchers_1.stripGroupSegmentsFromPath)(formattedPaths.url.pathname),baseUrl)+formattedPaths.url.search;if(!path.startsWith('/'))cleanPath=cleanPath.slice(1);if(formattedPaths.nonstandardPathname==='/'){return getStateFromEmptyPathWithConfigs(cleanPath,formattedPaths.url.hash.slice(1),configs,initialRoutes);}const routes=matchAgainstConfigs(formattedPaths.nonstandardPathname,configs);if(routes==null){return undefined;}return createNestedStateObject(cleanPath,formattedPaths.url.hash.slice(1),routes,configs,initialRoutes);}const joinPaths=(...paths)=>[].concat(...paths.map(p=>p.split('/'))).filter(Boolean).join('/');function matchAgainstConfigs(remaining,configs){let routes;let remainingPath=remaining;for(const config of configs){if(!config.regex){continue;}const match=remainingPath.match(config.regex);if(!match){continue;}const matchedParams=config.pattern?.split('/').filter(p=>p.match(/^[:*]/)).reduce((acc,p,i)=>{if(p.match(/^\\*/)){return _objectSpread(_objectSpread({},acc),{},{[p]:match[(i+1)*2]});}return Object.assign(acc,{[p]:match[(i+1)*2]?.replace(/\\//,'')});},{});const routeFromName=name=>{const config=configs.find(c=>c.screen===name);if(!config?.path){return{name};}const segments=config.path.split('/');const params={};segments.filter(p=>p.match(/^[:*]/)).forEach(p=>{let value=matchedParams[p];if(value){if(p.match(/^\\*/)){value=value?.split('/').filter(Boolean);}const key=p.replace(/^[:*]/,'').replace(/\\?$/,'');params[key]=config.parse?.[key]?config.parse[key](value):value;}});if(params&&Object.keys(params).length){return{name,params};}return{name};};routes=config.routeNames.map(name=>{if(!config._route){return _objectSpread({},routeFromName(name));}return _objectSpread(_objectSpread({},routeFromName(name)),{},{_route:config._route});});const combinedParams=routes.reduce((acc,r)=>Object.assign(acc,r.params),{});const hasCombinedParams=Object.keys(combinedParams).length>0;routes=routes.map(r=>{if(hasCombinedParams){r.params=combinedParams;}return r;});remainingPath=remainingPath.replace(match[1],'');break;}return routes;}function equalHeritage(a,b){if(a.length!==b.length){return false;}for(let i=0;i<a.length;i++){if(a[i].localeCompare(b[i])!==0){return false;}}return true;}const createNormalizedConfigs=(screen,routeConfig,routeNames=[],initials=[],parentScreens=[],parentPattern)=>{const configs=[];routeNames.push(screen);parentScreens.push(screen);const config=routeConfig[screen];if(typeof config==='string'){const pattern=parentPattern?joinPaths(parentPattern,config):config;configs.push(createConfigItem(screen,routeNames,pattern,config,false));}else if(typeof config==='object'){let pattern;const{_route}=config;if(typeof config.path==='string'){if(config.exact&&config.path===undefined){throw new Error(\"A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. `path: ''`.\");}pattern=config.exact!==true?joinPaths(parentPattern||'',config.path||''):config.path||'';configs.push(createConfigItem(screen,routeNames,pattern,config.path,config.screens?!!Object.keys(config.screens)?.length:false,config.parse,_route));}if(config.screens){if(config.initialRouteName){initials.push({initialRouteName:config.initialRouteName,parentScreens});}Object.keys(config.screens).forEach(nestedConfig=>{const result=createNormalizedConfigs(nestedConfig,config.screens,routeNames,initials,[...parentScreens],pattern??parentPattern);configs.push(...result);});}}routeNames.pop();return configs;};function formatRegexPattern(it){it=it.replace(' ','%20');if(it.startsWith(':')){return`(([^/]+\\\\/)${it.endsWith('?')?'?':''})`;}else if(it.startsWith('*')){return`((.*\\\\/)${it.endsWith('?')?'?':''})`;}if((0,matchers_1.matchGroupName)(it)!=null){return`(?:${(0,escape_string_regexp_1.default)(it)}\\\\/)?`;}return(0,escape_string_regexp_1.default)(it)+`\\\\/`;}const createConfigItem=(screen,routeNames,pattern,path,hasChildren,parse,_route)=>{pattern=pattern.split('/').filter(Boolean).join('/');const regex=pattern?new RegExp(`^(${pattern.split('/').map(formatRegexPattern).join('')})$`):undefined;return{screen,regex,pattern,path,routeNames:[...routeNames],parse,userReadableName:[...routeNames.slice(0,-1),path||screen].join('/'),hasChildren:!!hasChildren,_route};};const findParseConfigForRoute=(routeName,routeConfigs)=>{for(const config of routeConfigs){if(routeName===config.routeNames[config.routeNames.length-1]){return config.parse;}}return undefined;};const findInitialRoute=(routeName,parentScreens,initialRoutes)=>{for(const config of initialRoutes){if(equalHeritage(parentScreens,config.parentScreens)){return routeName!==config.initialRouteName?config.initialRouteName:undefined;}}return undefined;};const createStateObject=(route,isEmpty,initialRoute)=>{if(isEmpty){if(initialRoute){return{index:1,routes:[{name:initialRoute},route]};}return{routes:[route]};}if(initialRoute){return{index:1,routes:[{name:initialRoute},_objectSpread(_objectSpread({},route),{},{state:{routes:[]}})]};}return{routes:[_objectSpread(_objectSpread({},route),{},{state:{routes:[]}})]};};const createNestedStateObject=(path,hash,routes,routeConfigs,initialRoutes)=>{let route=routes.shift();const parentScreens=[];let initialRoute=findInitialRoute(route.name,parentScreens,initialRoutes);parentScreens.push(route.name);const state=createStateObject(route,routes.length===0,initialRoute);if(routes.length>0){let nestedState=state;while(route=routes.shift()){initialRoute=findInitialRoute(route.name,parentScreens,initialRoutes);const nestedStateIndex=nestedState.index||nestedState.routes.length-1;nestedState.routes[nestedStateIndex].state=createStateObject(route,routes.length===0,initialRoute);if(routes.length>0){nestedState=nestedState.routes[nestedStateIndex].state;}parentScreens.push(route.name);}}route=(0,findFocusedRoute_1.findFocusedRoute)(state);route.path=path;const params=parseQueryParams(route.path,findParseConfigForRoute(route.name,routeConfigs));if(params){route.params=Object.assign(Object.create(null),route.params);for(const[name,value]of Object.entries(params)){if(route.params?.[name]){if(false){console.warn(`Route '/${route.name}' with param '${name}' was specified both in the path and as a param, removing from path`);}}if(!route.params?.[name]){route.params[name]=value;continue;}}if(Object.keys(route.params).length===0){delete route.params;}}if(hash){route.params=Object.assign(Object.create(null),route.params);route.params['#']=hash;}return state;};const parseQueryParams=(path,parseConfig)=>{const query=path.split('?')[1];const searchParams=new URLSearchParams(query);const params=Object.fromEntries(searchParams);if(parseConfig){Object.keys(params).forEach(name=>{if(Object.hasOwnProperty.call(parseConfig,name)&&typeof params[name]==='string'){params[name]=parseConfig[name](params[name]);}});}return Object.keys(params).length?params:undefined;};const baseUrlCache=new Map();function getBaseUrlRegex(baseUrl){if(baseUrlCache.has(baseUrl)){return baseUrlCache.get(baseUrl);}const regex=new RegExp(`^\\\\/?${(0,escape_string_regexp_1.default)(baseUrl)}`,'g');baseUrlCache.set(baseUrl,regex);return regex;}function stripBaseUrl(path,baseUrl=\"\"){if(true){if(baseUrl){const reg=getBaseUrlRegex(baseUrl);return path.replace(/^\\/+/g,'/').replace(reg,'');}}return path;}exports.stripBaseUrl=stripBaseUrl;","map":{"version":3,"names":["escape_string_regexp_1","__importDefault","require","findFocusedRoute_1","validatePathConfig_1","matchers_1","getUrlWithReactNavigationConcessions","path","baseUrl","parsed","URL","nonstandardPathname","inputPathnameWithoutHash","url","pathname","stripBaseUrl","replace","exports","getStateFromPath","options","initialRoutes","configs","getMatchableRouteConfigs","getStateFromPathWithConfigs","default","screens","Error","initialRouteName","push","parentScreens","converted","Object","keys","map","key","createNormalizedConfigs","flat","resolvedInitialPatterns","route","joinPaths","convertedWithInitial","config","_objectSpread","isInitial","includes","routeNames","join","sort","sortConfigs","assertConfigDuplicates","reduce","acc","indexedKey","regex","toString","pattern","alpha","hasChildren","a","b","intersects","length","every","it","i","last","split","pop","match","routeType","startsWith","userReadableName","assign","localeCompare","screen","aParts","filter","part","matchGroupName","bParts","Math","max","aWildCard","bWildCard","aNotFound","bNotFound","aSlug","bSlug","getStateFromEmptyPathWithConfigs","hash","leafNodes","value","stripGroupSegmentsFromPath","find","test","undefined","routes","name","_route","createNestedStateObject","formattedPaths","cleanPath","search","slice","matchAgainstConfigs","paths","concat","p","Boolean","remaining","remainingPath","matchedParams","routeFromName","c","segments","params","forEach","parse","combinedParams","r","hasCombinedParams","equalHeritage","routeConfig","initials","parentPattern","createConfigItem","exact","nestedConfig","result","formatRegexPattern","endsWith","RegExp","findParseConfigForRoute","routeName","routeConfigs","findInitialRoute","createStateObject","isEmpty","initialRoute","index","state","shift","nestedState","nestedStateIndex","findFocusedRoute","parseQueryParams","create","entries","console","warn","parseConfig","query","searchParams","URLSearchParams","fromEntries","hasOwnProperty","call","baseUrlCache","Map","getBaseUrlRegex","has","get","set","reg"],"sources":["/Users/apple/FounderFinder/node_modules/expo-router/src/fork/getStateFromPath.ts"],"sourcesContent":["import { PathConfigMap } from '@react-navigation/core';\nimport type { InitialState, NavigationState, PartialState } from '@react-navigation/routers';\nimport escape from 'escape-string-regexp';\n\nimport { findFocusedRoute } from './findFocusedRoute';\nimport validatePathConfig from './validatePathConfig';\nimport { RouteNode } from '../Route';\nimport { matchGroupName, stripGroupSegmentsFromPath } from '../matchers';\n\ntype Options<ParamList extends object> = {\n  initialRouteName?: string;\n  screens: PathConfigMap<ParamList>;\n};\n\ntype ParseConfig = Record<string, (value: string) => any>;\n\ntype RouteConfig = {\n  isInitial?: boolean;\n  screen: string;\n  regex?: RegExp;\n  path: string;\n  pattern: string;\n  routeNames: string[];\n  parse?: ParseConfig;\n  hasChildren: boolean;\n  userReadableName: string;\n  _route?: RouteNode;\n};\n\ntype InitialRouteConfig = {\n  initialRouteName: string;\n  parentScreens: string[];\n};\n\nexport type ResultState = PartialState<NavigationState> & {\n  state?: ResultState;\n};\n\ntype ParsedRoute = {\n  name: string;\n  path?: string;\n  params?: Record<string, any>;\n};\n\nexport function getUrlWithReactNavigationConcessions(\n  path: string,\n  baseUrl: string | undefined = process.env.EXPO_BASE_URL\n) {\n  let parsed: URL;\n  try {\n    parsed = new URL(path, 'https://phony.example');\n  } catch {\n    // Do nothing with invalid URLs.\n    return {\n      nonstandardPathname: '',\n      inputPathnameWithoutHash: '',\n      url: null,\n    };\n  }\n\n  const pathname = parsed.pathname;\n\n  // Make sure there is a trailing slash\n  return {\n    // The slashes are at the end, not the beginning\n    nonstandardPathname:\n      stripBaseUrl(pathname, baseUrl).replace(/^\\/+/g, '').replace(/\\/+$/g, '') + '/',\n    url: parsed,\n  };\n}\n\n/**\n * Utility to parse a path string to initial state object accepted by the container.\n * This is useful for deep linking when we need to handle the incoming URL.\n *\n * @example\n * ```js\n * getStateFromPath(\n *   '/chat/jane/42',\n *   {\n *     screens: {\n *       Chat: {\n *         path: 'chat/:author/:id',\n *         parse: { id: Number }\n *       }\n *     }\n *   }\n * )\n * ```\n * @param path Path string to parse and convert, e.g. /foo/bar?count=42.\n * @param options Extra options to fine-tune how to parse the path.\n */\nexport default function getStateFromPath<ParamList extends object>(\n  path: string,\n  options?: Options<ParamList>\n): ResultState | undefined {\n  const { initialRoutes, configs } = getMatchableRouteConfigs(options);\n\n  return getStateFromPathWithConfigs(path, configs, initialRoutes);\n}\n\nexport function getMatchableRouteConfigs<ParamList extends object>(options?: Options<ParamList>) {\n  if (options) {\n    validatePathConfig(options);\n  }\n\n  const screens = options?.screens;\n  // Expo Router disallows usage without a linking config.\n  if (!screens) {\n    throw Error(\"You must pass a 'screens' object to 'getStateFromPath' to generate a path.\");\n  }\n\n  // This will be mutated...\n  const initialRoutes: InitialRouteConfig[] = [];\n\n  if (options?.initialRouteName) {\n    initialRoutes.push({\n      initialRouteName: options.initialRouteName,\n      parentScreens: [],\n    });\n  }\n\n  // Create a normalized configs array which will be easier to use.\n  const converted = Object.keys(screens)\n    .map((key) => createNormalizedConfigs(key, screens, [], initialRoutes))\n    .flat();\n\n  const resolvedInitialPatterns = initialRoutes.map((route) =>\n    joinPaths(...route.parentScreens, route.initialRouteName)\n  );\n\n  const convertedWithInitial = converted.map((config) => ({\n    ...config,\n    // TODO(EvanBacon): Probably a safer way to do this\n    // Mark initial routes to give them potential priority over other routes that match.\n    isInitial: resolvedInitialPatterns.includes(config.routeNames.join('/')),\n  }));\n\n  // Sort in order of resolution. This is extremely important for the algorithm to work.\n  const configs = convertedWithInitial.sort(sortConfigs);\n\n  // Assert any duplicates before we start parsing.\n  assertConfigDuplicates(configs);\n\n  return { configs, initialRoutes };\n}\n\nfunction assertConfigDuplicates(configs: RouteConfig[]) {\n  // Check for duplicate patterns in the config\n  configs.reduce<Record<string, RouteConfig>>((acc, config) => {\n    // NOTE(EvanBacon): Uses the regex pattern as key to detect duplicate slugs.\n    const indexedKey = config.regex?.toString() ?? config.pattern;\n    const alpha = acc[indexedKey];\n    // NOTE(EvanBacon): Skips checking nodes that have children.\n    if (alpha && !alpha.hasChildren && !config.hasChildren) {\n      const a = alpha.routeNames;\n      const b = config.routeNames;\n\n      // It's not a problem if the path string omitted from a inner most screen\n      // For example, it's ok if a path resolves to `A > B > C` or `A > B`\n      const intersects =\n        a.length > b.length ? b.every((it, i) => a[i] === it) : a.every((it, i) => b[i] === it);\n\n      if (!intersects) {\n        // NOTE(EvanBacon): Adds more context to the error message since we know about the\n        // file-based routing.\n        const last = config.pattern.split('/').pop();\n\n        if (!last?.match(/^\\*not-found$/)) {\n          const routeType = last?.startsWith(':')\n            ? 'dynamic route'\n            : last?.startsWith('*')\n              ? 'dynamic-rest route'\n              : 'route';\n          throw new Error(\n            `The ${routeType} pattern '${config.pattern || '/'}' resolves to both '${\n              alpha.userReadableName\n            }' and '${\n              config.userReadableName\n            }'. Patterns must be unique and cannot resolve to more than one route.`\n          );\n        }\n      }\n    }\n\n    return Object.assign(acc, {\n      [indexedKey]: config,\n    });\n  }, {});\n}\n\nfunction sortConfigs(a: RouteConfig, b: RouteConfig): number {\n  // Sort config so that:\n  // - the most exhaustive ones are always at the beginning\n  // - patterns with wildcard are always at the end\n\n  // If 2 patterns are same, move the one with less route names up\n  // This is an error state, so it's only useful for consistent error messages\n  if (a.pattern === b.pattern) {\n    return b.routeNames.join('>').localeCompare(a.routeNames.join('>'));\n  }\n\n  // If one of the patterns starts with the other, it's more exhaustive\n  // So move it up\n  if (\n    a.pattern.startsWith(b.pattern) &&\n    // NOTE(EvanBacon): This is a hack to make sure that `*` is always at the end\n    b.screen !== 'index'\n  ) {\n    return -1;\n  }\n\n  if (b.pattern.startsWith(a.pattern) && a.screen !== 'index') {\n    return 1;\n  }\n\n  // NOTE(EvanBacon): Here we append `index` if the screen was `index` so the length is the same\n  // as a slug or wildcard when nested more than one level deep.\n  // This is so we can compare the length of the pattern, e.g. `foo/*` > `foo` vs `*` < ``.\n  const aParts = a.pattern\n    .split('/')\n    // Strip out group names to ensure they don't affect the priority.\n    .filter((part) => matchGroupName(part) == null);\n  if (a.screen === 'index' || a.screen.match(/\\/index$/)) {\n    aParts.push('index');\n  }\n\n  const bParts = b.pattern.split('/').filter((part) => matchGroupName(part) == null);\n  if (b.screen === 'index' || b.screen.match(/\\/index$/)) {\n    bParts.push('index');\n  }\n\n  for (let i = 0; i < Math.max(aParts.length, bParts.length); i++) {\n    // if b is longer, b get higher priority\n    if (aParts[i] == null) {\n      return 1;\n    }\n    // if a is longer, a get higher priority\n    if (bParts[i] == null) {\n      return -1;\n    }\n\n    const aWildCard = aParts[i].startsWith('*');\n    const bWildCard = bParts[i].startsWith('*');\n    // if both are wildcard we compare next component\n    if (aWildCard && bWildCard) {\n      const aNotFound = aParts[i].match(/^[*]not-found$/);\n      const bNotFound = bParts[i].match(/^[*]not-found$/);\n\n      if (aNotFound && bNotFound) {\n        continue;\n      } else if (aNotFound) {\n        return 1;\n      } else if (bNotFound) {\n        return -1;\n      }\n      continue;\n    }\n    // if only a is wild card, b get higher priority\n    if (aWildCard) {\n      return 1;\n    }\n    // if only b is wild card, a get higher priority\n    if (bWildCard) {\n      return -1;\n    }\n\n    const aSlug = aParts[i].startsWith(':');\n    const bSlug = bParts[i].startsWith(':');\n    // if both are wildcard we compare next component\n    if (aSlug && bSlug) {\n      const aNotFound = aParts[i].match(/^[*]not-found$/);\n      const bNotFound = bParts[i].match(/^[*]not-found$/);\n\n      if (aNotFound && bNotFound) {\n        continue;\n      } else if (aNotFound) {\n        return 1;\n      } else if (bNotFound) {\n        return -1;\n      }\n\n      continue;\n    }\n    // if only a is wild card, b get higher priority\n    if (aSlug) {\n      return 1;\n    }\n    // if only b is wild card, a get higher priority\n    if (bSlug) {\n      return -1;\n    }\n  }\n\n  // Sort initial routes with a higher priority than routes which will push more screens\n  // this ensures shared routes go to the shortest path.\n  if (a.isInitial && !b.isInitial) {\n    return -1;\n  }\n  if (!a.isInitial && b.isInitial) {\n    return 1;\n  }\n\n  return bParts.length - aParts.length;\n}\n\nfunction getStateFromEmptyPathWithConfigs(\n  path: string,\n  hash: string,\n  configs: RouteConfig[],\n  initialRoutes: InitialRouteConfig[]\n): ResultState | undefined {\n  // We need to add special handling of empty path so navigation to empty path also works\n  // When handling empty path, we should only look at the root level config\n\n  // NOTE(EvanBacon): We only care about matching leaf nodes.\n  const leafNodes = configs\n    .filter((config) => !config.hasChildren)\n    .map((value) => {\n      return {\n        ...value,\n        // Collapse all levels of group segments before testing.\n        // This enables `app/(one)/(two)/index.js` to be matched.\n        path: stripGroupSegmentsFromPath(value.path),\n      };\n    });\n\n  const match =\n    leafNodes.find(\n      (config) =>\n        // NOTE(EvanBacon): Test leaf node index routes that either don't have a regex or match an empty string.\n        config.path === '' && (!config.regex || config.regex.test(''))\n    ) ??\n    leafNodes.find(\n      (config) =>\n        // NOTE(EvanBacon): Test leaf node dynamic routes that match an empty string.\n        config.path.startsWith(':') && config.regex!.test('')\n    ) ??\n    // NOTE(EvanBacon): Test leaf node deep dynamic routes that match a slash.\n    // This should be done last to enable dynamic routes having a higher priority.\n    leafNodes.find((config) => config.path.startsWith('*') && config.regex!.test('/'));\n\n  if (!match) {\n    return undefined;\n  }\n\n  const routes = match.routeNames.map((name) => {\n    if (!match._route) {\n      return { name };\n    }\n    return {\n      name,\n      _route: match._route,\n    };\n  });\n\n  return createNestedStateObject(path, hash, routes, configs, initialRoutes);\n}\n\nfunction getStateFromPathWithConfigs(\n  path: string,\n  configs: RouteConfig[],\n  initialRoutes: InitialRouteConfig[],\n  baseUrl: string | undefined = process.env.EXPO_BASE_URL\n): ResultState | undefined {\n  const formattedPaths = getUrlWithReactNavigationConcessions(path);\n\n  if (!formattedPaths.url) return;\n\n  let cleanPath =\n    stripBaseUrl(stripGroupSegmentsFromPath(formattedPaths.url.pathname), baseUrl) +\n    formattedPaths.url.search;\n\n  if (!path.startsWith('/')) cleanPath = cleanPath.slice(1);\n\n  if (formattedPaths.nonstandardPathname === '/') {\n    return getStateFromEmptyPathWithConfigs(\n      cleanPath,\n      formattedPaths.url.hash.slice(1),\n      configs,\n      initialRoutes\n    );\n  }\n\n  // We match the whole path against the regex instead of segments\n  // This makes sure matches such as wildcard will catch any unmatched routes, even if nested\n  const routes = matchAgainstConfigs(formattedPaths.nonstandardPathname, configs);\n\n  if (routes == null) {\n    return undefined;\n  }\n  // This will always be empty if full path matched\n  return createNestedStateObject(\n    cleanPath,\n    formattedPaths.url.hash.slice(1),\n    routes,\n    configs,\n    initialRoutes\n  );\n}\n\nconst joinPaths = (...paths: string[]): string =>\n  ([] as string[])\n    .concat(...paths.map((p) => p.split('/')))\n    .filter(Boolean)\n    .join('/');\n\nfunction matchAgainstConfigs(remaining: string, configs: RouteConfig[]): ParsedRoute[] | undefined {\n  let routes: ParsedRoute[] | undefined;\n  let remainingPath = remaining;\n\n  // Go through all configs, and see if the next path segment matches our regex\n  for (const config of configs) {\n    if (!config.regex) {\n      continue;\n    }\n\n    const match = remainingPath.match(config.regex);\n\n    // If our regex matches, we need to extract params from the path\n    if (!match) {\n      continue;\n    }\n\n    // TODO: Add support for wildcard routes\n    const matchedParams = config.pattern\n      ?.split('/')\n      .filter((p) => p.match(/^[:*]/))\n      .reduce<Record<string, any>>((acc, p, i) => {\n        if (p.match(/^\\*/)) {\n          return {\n            ...acc,\n            [p]: match![(i + 1) * 2], //?.replace(/\\//, \"\"),\n          };\n        }\n        return Object.assign(acc, {\n          // The param segments appear every second item starting from 2 in the regex match result.\n          // This will only work if we ensure groups aren't included in the match.\n          [p]: match![(i + 1) * 2]?.replace(/\\//, ''),\n        });\n      }, {});\n\n    const routeFromName = (name: string) => {\n      const config = configs.find((c) => c.screen === name);\n      if (!config?.path) {\n        return { name };\n      }\n\n      const segments = config.path.split('/');\n\n      const params: Record<string, any> = {};\n\n      segments\n        .filter((p) => p.match(/^[:*]/))\n        .forEach((p) => {\n          let value = matchedParams[p];\n          if (value) {\n            if (p.match(/^\\*/)) {\n              // Convert to an array before providing as a route.\n              value = value?.split('/').filter(Boolean);\n            }\n\n            const key = p.replace(/^[:*]/, '').replace(/\\?$/, '');\n            params[key] = config.parse?.[key] ? config.parse[key](value) : value;\n          }\n        });\n\n      if (params && Object.keys(params).length) {\n        return { name, params };\n      }\n\n      return { name };\n    };\n\n    routes = config.routeNames.map((name) => {\n      if (!config._route) {\n        return { ...routeFromName(name) };\n      }\n      return {\n        ...routeFromName(name),\n        _route: config._route,\n      };\n    });\n\n    // TODO(EvanBacon): Maybe we should warn / assert if multiple slugs use the same param name.\n    const combinedParams = routes.reduce<Record<string, any>>(\n      (acc, r) => Object.assign(acc, r.params),\n      {}\n    );\n\n    const hasCombinedParams = Object.keys(combinedParams).length > 0;\n\n    // Combine all params so a route `[foo]/[bar]/other.js` has access to `{ foo, bar }`\n    routes = routes.map((r) => {\n      if (hasCombinedParams) {\n        r.params = combinedParams;\n      }\n      return r;\n    });\n\n    remainingPath = remainingPath.replace(match[1], '');\n\n    break;\n  }\n\n  return routes;\n}\n\nfunction equalHeritage(a: string[], b: string[]): boolean {\n  if (a.length !== b.length) {\n    return false;\n  }\n  for (let i = 0; i < a.length; i++) {\n    if (a[i].localeCompare(b[i]) !== 0) {\n      return false;\n    }\n  }\n  return true;\n}\n\nconst createNormalizedConfigs = (\n  screen: string,\n  routeConfig: PathConfigMap<object>,\n  routeNames: string[] = [],\n  initials: InitialRouteConfig[] = [],\n  parentScreens: string[] = [],\n  parentPattern?: string\n): RouteConfig[] => {\n  const configs: RouteConfig[] = [];\n\n  routeNames.push(screen);\n\n  parentScreens.push(screen);\n\n  const config = (routeConfig as any)[screen];\n\n  if (typeof config === 'string') {\n    // TODO: This should never happen with the addition of `_route`\n\n    // If a string is specified as the value of the key(e.g. Foo: '/path'), use it as the pattern\n    const pattern = parentPattern ? joinPaths(parentPattern, config) : config;\n\n    configs.push(createConfigItem(screen, routeNames, pattern, config, false));\n  } else if (typeof config === 'object') {\n    let pattern: string | undefined;\n\n    const { _route } = config;\n    // if an object is specified as the value (e.g. Foo: { ... }),\n    // it can have `path` property and\n    // it could have `screens` prop which has nested configs\n    if (typeof config.path === 'string') {\n      if (config.exact && config.path === undefined) {\n        throw new Error(\n          \"A 'path' needs to be specified when specifying 'exact: true'. If you don't want this screen in the URL, specify it as empty string, e.g. `path: ''`.\"\n        );\n      }\n\n      pattern =\n        config.exact !== true\n          ? joinPaths(parentPattern || '', config.path || '')\n          : config.path || '';\n\n      configs.push(\n        createConfigItem(\n          screen,\n          routeNames,\n          pattern!,\n          config.path,\n          config.screens ? !!Object.keys(config.screens)?.length : false,\n          config.parse,\n          _route\n        )\n      );\n    }\n\n    if (config.screens) {\n      // property `initialRouteName` without `screens` has no purpose\n      if (config.initialRouteName) {\n        initials.push({\n          initialRouteName: config.initialRouteName,\n          parentScreens,\n        });\n      }\n\n      Object.keys(config.screens).forEach((nestedConfig) => {\n        const result = createNormalizedConfigs(\n          nestedConfig,\n          config.screens as PathConfigMap<object>,\n          routeNames,\n          initials,\n          [...parentScreens],\n          pattern ?? parentPattern\n        );\n\n        configs.push(...result);\n      });\n    }\n  }\n\n  routeNames.pop();\n\n  return configs;\n};\n\nfunction formatRegexPattern(it: string): string {\n  // Allow spaces in file path names.\n  it = it.replace(' ', '%20');\n\n  if (it.startsWith(':')) {\n    // TODO: Remove unused match group\n    return `(([^/]+\\\\/)${it.endsWith('?') ? '?' : ''})`;\n  } else if (it.startsWith('*')) {\n    return `((.*\\\\/)${it.endsWith('?') ? '?' : ''})`;\n  }\n\n  // Strip groups from the matcher\n  if (matchGroupName(it) != null) {\n    // Groups are optional segments\n    // this enables us to match `/bar` and `/(foo)/bar` for the same route\n    // NOTE(EvanBacon): Ignore this match in the regex to avoid capturing the group\n    return `(?:${escape(it)}\\\\/)?`;\n  }\n\n  return escape(it) + `\\\\/`;\n}\n\nconst createConfigItem = (\n  screen: string,\n  routeNames: string[],\n  pattern: string,\n  path: string,\n  hasChildren?: boolean,\n  parse?: ParseConfig,\n  _route?: any\n): RouteConfig => {\n  // Normalize pattern to remove any leading, trailing slashes, duplicate slashes etc.\n  pattern = pattern.split('/').filter(Boolean).join('/');\n\n  const regex = pattern\n    ? new RegExp(`^(${pattern.split('/').map(formatRegexPattern).join('')})$`)\n    : undefined;\n\n  return {\n    screen,\n    regex,\n    pattern,\n    path,\n    // The routeNames array is mutated, so copy it to keep the current state\n    routeNames: [...routeNames],\n    parse,\n    userReadableName: [...routeNames.slice(0, -1), path || screen].join('/'),\n    hasChildren: !!hasChildren,\n    _route,\n  };\n};\n\nconst findParseConfigForRoute = (\n  routeName: string,\n  routeConfigs: RouteConfig[]\n): ParseConfig | undefined => {\n  for (const config of routeConfigs) {\n    if (routeName === config.routeNames[config.routeNames.length - 1]) {\n      return config.parse;\n    }\n  }\n\n  return undefined;\n};\n\n// Try to find an initial route connected with the one passed\nconst findInitialRoute = (\n  routeName: string,\n  parentScreens: string[],\n  initialRoutes: InitialRouteConfig[]\n): string | undefined => {\n  for (const config of initialRoutes) {\n    if (equalHeritage(parentScreens, config.parentScreens)) {\n      // If the parents are the same but the route name doesn't match the initial route\n      // then we return the initial route.\n      return routeName !== config.initialRouteName ? config.initialRouteName : undefined;\n    }\n  }\n  return undefined;\n};\n\n// returns state object with values depending on whether\n// it is the end of state and if there is initialRoute for this level\nconst createStateObject = (\n  route: ParsedRoute,\n  isEmpty: boolean,\n  initialRoute?: string\n): InitialState => {\n  if (isEmpty) {\n    if (initialRoute) {\n      return {\n        index: 1,\n        routes: [{ name: initialRoute }, route],\n      };\n    }\n    return {\n      routes: [route],\n    };\n  }\n\n  if (initialRoute) {\n    return {\n      index: 1,\n      routes: [{ name: initialRoute }, { ...route, state: { routes: [] } }],\n    };\n  }\n  return {\n    routes: [{ ...route, state: { routes: [] } }],\n  };\n};\n\nconst createNestedStateObject = (\n  path: string,\n  hash: string | undefined,\n  routes: ParsedRoute[],\n  routeConfigs: RouteConfig[],\n  initialRoutes: InitialRouteConfig[]\n) => {\n  let route = routes.shift() as ParsedRoute;\n  const parentScreens: string[] = [];\n\n  let initialRoute = findInitialRoute(route.name, parentScreens, initialRoutes);\n\n  parentScreens.push(route.name);\n\n  const state: InitialState = createStateObject(route, routes.length === 0, initialRoute);\n\n  if (routes.length > 0) {\n    let nestedState = state;\n\n    while ((route = routes.shift() as ParsedRoute)) {\n      initialRoute = findInitialRoute(route.name, parentScreens, initialRoutes);\n\n      const nestedStateIndex = nestedState.index || nestedState.routes.length - 1;\n\n      nestedState.routes[nestedStateIndex].state = createStateObject(\n        route,\n        routes.length === 0,\n        initialRoute\n      );\n\n      if (routes.length > 0) {\n        nestedState = nestedState.routes[nestedStateIndex].state as InitialState;\n      }\n\n      parentScreens.push(route.name);\n    }\n  }\n\n  route = findFocusedRoute(state) as ParsedRoute;\n\n  // Remove groups from the path while preserving a trailing slash.\n  route.path = path;\n\n  const params = parseQueryParams(route.path, findParseConfigForRoute(route.name, routeConfigs));\n\n  if (params) {\n    route.params = Object.assign(Object.create(null), route.params) as Record<string, any>;\n    for (const [name, value] of Object.entries(params)) {\n      if (route.params?.[name]) {\n        if (process.env.NODE_ENV !== 'production') {\n          console.warn(\n            `Route '/${route.name}' with param '${name}' was specified both in the path and as a param, removing from path`\n          );\n        }\n      }\n\n      if (!route.params?.[name]) {\n        route.params[name] = value;\n        continue;\n      }\n    }\n\n    if (Object.keys(route.params).length === 0) {\n      delete route.params;\n    }\n  }\n\n  if (hash) {\n    route.params = Object.assign(Object.create(null), route.params) as Record<string, any>;\n    route.params['#'] = hash;\n  }\n\n  return state;\n};\n\nconst parseQueryParams = (path: string, parseConfig?: Record<string, (value: string) => any>) => {\n  const query = path.split('?')[1];\n  const searchParams = new URLSearchParams(query);\n  const params = Object.fromEntries(\n    // @ts-ignore: [Symbol.iterator] is indeed, available on every platform.\n    searchParams\n  );\n\n  if (parseConfig) {\n    Object.keys(params).forEach((name) => {\n      if (Object.hasOwnProperty.call(parseConfig, name) && typeof params[name] === 'string') {\n        params[name] = parseConfig[name](params[name] as string);\n      }\n    });\n  }\n\n  return Object.keys(params).length ? params : undefined;\n};\n\nconst baseUrlCache = new Map<string, RegExp>();\n\nfunction getBaseUrlRegex(baseUrl: string) {\n  if (baseUrlCache.has(baseUrl)) {\n    return baseUrlCache.get(baseUrl)!;\n  }\n  const regex = new RegExp(`^\\\\/?${escape(baseUrl)}`, 'g');\n  baseUrlCache.set(baseUrl, regex);\n  return regex;\n}\n\nexport function stripBaseUrl(\n  path: string,\n  baseUrl: string | undefined = process.env.EXPO_BASE_URL\n) {\n  if (process.env.NODE_ENV !== 'development') {\n    if (baseUrl) {\n      const reg = getBaseUrlRegex(baseUrl);\n      return path.replace(/^\\/+/g, '/').replace(reg, '');\n    }\n  }\n  return path;\n}\n"],"mappings":"g9BAEA,MAAAA,sBAAA,CAAAC,eAAA,CAAAC,OAAA,0BAEA,MAAAC,kBAAA,CAAAD,OAAA,uBACA,MAAAE,oBAAA,CAAAH,eAAA,CAAAC,OAAA,0BAEA,MAAAG,UAAA,CAAAH,OAAA,gBAqCA,QAAgB,CAAAI,oCAAoCA,CAClDC,IAAY,CACZC,OAAA,GAAuD,EAEvD,GAAI,CAAAC,MAAW,CACf,GAAI,CACFA,MAAM,CAAG,GAAI,CAAAC,GAAG,CAACH,IAAI,CAAE,uBAAuB,CAAC,C,CAC/C,KAAM,CAEN,MAAO,CACLI,mBAAmB,CAAE,EAAE,CACvBC,wBAAwB,CAAE,EAAE,CAC5BC,GAAG,CAAE,I,CACN,C,CAGH,KAAM,CAAAC,QAAQ,CAAGL,MAAM,CAACK,QAAQ,CAGhC,MAAO,CAELH,mBAAmB,CACjBI,YAAY,CAACD,QAAQ,CAAEN,OAAO,CAAC,CAACQ,OAAO,CAAC,OAAO,CAAE,EAAE,CAAC,CAACA,OAAO,CAAC,OAAO,CAAE,EAAE,CAAC,CAAG,GAAG,CACjFH,GAAG,CAAEJ,M,CACN,CACH,CAzBAQ,OAAA,CAAAX,oCAAA,CAAAA,oCAAA,CAgDA,QAAwB,CAAAY,gBAAgBA,CACtCX,IAAY,CACZY,OAA4B,EAE5B,KAAM,CAAEC,aAAa,CAAEC,OAAO,CAAE,CAAGC,wBAAwB,CAACH,OAAO,CAAC,CAEpE,MAAO,CAAAI,2BAA2B,CAAChB,IAAI,CAAEc,OAAO,CAAED,aAAa,CAAC,CAClE,CAPAH,OAAA,CAAAO,OAAA,CAAAN,gBAAA,CASA,QAAgB,CAAAI,wBAAwBA,CAA2BH,OAA4B,EAC7F,GAAIA,OAAO,CAAE,CACX,GAAAf,oBAAA,CAAAoB,OAAkB,EAACL,OAAO,CAAC,C,CAG7B,KAAM,CAAAM,OAAO,CAAGN,OAAO,EAAEM,OAAO,CAEhC,GAAI,CAACA,OAAO,CAAE,CACZ,KAAM,CAAAC,KAAK,CAAC,4EAA4E,CAAC,C,CAI3F,KAAM,CAAAN,aAAa,CAAyB,EAAE,CAE9C,GAAID,OAAO,EAAEQ,gBAAgB,CAAE,CAC7BP,aAAa,CAACQ,IAAI,CAAC,CACjBD,gBAAgB,CAAER,OAAO,CAACQ,gBAAgB,CAC1CE,aAAa,CAAE,E,CAChB,CAAC,C,CAIJ,KAAM,CAAAC,SAAS,CAAGC,MAAM,CAACC,IAAI,CAACP,OAAO,CAAC,CACnCQ,GAAG,CAAEC,GAAG,EAAKC,uBAAuB,CAACD,GAAG,CAAET,OAAO,CAAE,EAAE,CAAEL,aAAa,CAAC,CAAC,CACtEgB,IAAI,EAAE,CAET,KAAM,CAAAC,uBAAuB,CAAGjB,aAAa,CAACa,GAAG,CAAEK,KAAK,EACtDC,SAAS,CAAC,GAAGD,KAAK,CAACT,aAAa,CAAES,KAAK,CAACX,gBAAgB,CAAC,CAC1D,CAED,KAAM,CAAAa,oBAAoB,CAAGV,SAAS,CAACG,GAAG,CAAEQ,MAAM,EAAAC,aAAA,CAAAA,aAAA,IAC7CD,MAAM,MAGTE,SAAS,CAAEN,uBAAuB,CAACO,QAAQ,CAACH,MAAM,CAACI,UAAU,CAACC,IAAI,CAAC,GAAG,CAAC,CAAC,EACxE,CAAC,CAGH,KAAM,CAAAzB,OAAO,CAAGmB,oBAAoB,CAACO,IAAI,CAACC,WAAW,CAAC,CAGtDC,sBAAsB,CAAC5B,OAAO,CAAC,CAE/B,MAAO,CAAEA,OAAO,CAAED,aAAa,CAAE,CACnC,CA5CAH,OAAA,CAAAK,wBAAA,CAAAA,wBAAA,CA8CA,QAAS,CAAA2B,sBAAsBA,CAAC5B,OAAsB,EAEpDA,OAAO,CAAC6B,MAAM,CAA8B,CAACC,GAAG,CAAEV,MAAM,GAAI,CAE1D,KAAM,CAAAW,UAAU,CAAGX,MAAM,CAACY,KAAK,EAAEC,QAAQ,EAAE,EAAIb,MAAM,CAACc,OAAO,CAC7D,KAAM,CAAAC,KAAK,CAAGL,GAAG,CAACC,UAAU,CAAC,CAE7B,GAAII,KAAK,EAAI,CAACA,KAAK,CAACC,WAAW,EAAI,CAAChB,MAAM,CAACgB,WAAW,CAAE,CACtD,KAAM,CAAAC,CAAC,CAAGF,KAAK,CAACX,UAAU,CAC1B,KAAM,CAAAc,CAAC,CAAGlB,MAAM,CAACI,UAAU,CAI3B,KAAM,CAAAe,UAAU,CACdF,CAAC,CAACG,MAAM,CAAGF,CAAC,CAACE,MAAM,CAAGF,CAAC,CAACG,KAAK,CAAC,CAACC,EAAE,CAAEC,CAAC,GAAKN,CAAC,CAACM,CAAC,CAAC,GAAKD,EAAE,CAAC,CAAGL,CAAC,CAACI,KAAK,CAAC,CAACC,EAAE,CAAEC,CAAC,GAAKL,CAAC,CAACK,CAAC,CAAC,GAAKD,EAAE,CAAC,CAEzF,GAAI,CAACH,UAAU,CAAE,CAGf,KAAM,CAAAK,IAAI,CAAGxB,MAAM,CAACc,OAAO,CAACW,KAAK,CAAC,GAAG,CAAC,CAACC,GAAG,EAAE,CAE5C,GAAI,CAACF,IAAI,EAAEG,KAAK,CAAC,eAAe,CAAC,CAAE,CACjC,KAAM,CAAAC,SAAS,CAAGJ,IAAI,EAAEK,UAAU,CAAC,GAAG,CAAC,CACnC,eAAe,CACfL,IAAI,EAAEK,UAAU,CAAC,GAAG,CAAC,CACnB,oBAAoB,CACpB,OAAO,CACb,KAAM,IAAI,CAAA5C,KAAK,CACb,OAAO2C,SAAS,aAAa5B,MAAM,CAACc,OAAO,EAAI,GAAG,uBAChDC,KAAK,CAACe,gBACR,UACE9B,MAAM,CAAC8B,gBACT,uEAAuE,CACxE,C,GAKP,MAAO,CAAAxC,MAAM,CAACyC,MAAM,CAACrB,GAAG,CAAE,CACxB,CAACC,UAAU,EAAGX,M,CACf,CAAC,CACJ,CAAC,CAAE,EAAE,CAAC,CACR,CAEA,QAAS,CAAAO,WAAWA,CAACU,CAAc,CAAEC,CAAc,EAOjD,GAAID,CAAC,CAACH,OAAO,GAAKI,CAAC,CAACJ,OAAO,CAAE,CAC3B,MAAO,CAAAI,CAAC,CAACd,UAAU,CAACC,IAAI,CAAC,GAAG,CAAC,CAAC2B,aAAa,CAACf,CAAC,CAACb,UAAU,CAACC,IAAI,CAAC,GAAG,CAAC,CAAC,C,CAKrE,GACEY,CAAC,CAACH,OAAO,CAACe,UAAU,CAACX,CAAC,CAACJ,OAAO,CAAC,EAE/BI,CAAC,CAACe,MAAM,GAAK,OAAO,CACpB,CACA,MAAO,CAAC,CAAC,C,CAGX,GAAIf,CAAC,CAACJ,OAAO,CAACe,UAAU,CAACZ,CAAC,CAACH,OAAO,CAAC,EAAIG,CAAC,CAACgB,MAAM,GAAK,OAAO,CAAE,CAC3D,MAAO,EAAC,C,CAMV,KAAM,CAAAC,MAAM,CAAGjB,CAAC,CAACH,OAAO,CACrBW,KAAK,CAAC,GAAG,CAAC,CAEVU,MAAM,CAAEC,IAAI,EAAK,GAAAxE,UAAA,CAAAyE,cAAc,EAACD,IAAI,CAAC,EAAI,IAAI,CAAC,CACjD,GAAInB,CAAC,CAACgB,MAAM,GAAK,OAAO,EAAIhB,CAAC,CAACgB,MAAM,CAACN,KAAK,CAAC,UAAU,CAAC,CAAE,CACtDO,MAAM,CAAC/C,IAAI,CAAC,OAAO,CAAC,C,CAGtB,KAAM,CAAAmD,MAAM,CAAGpB,CAAC,CAACJ,OAAO,CAACW,KAAK,CAAC,GAAG,CAAC,CAACU,MAAM,CAAEC,IAAI,EAAK,GAAAxE,UAAA,CAAAyE,cAAc,EAACD,IAAI,CAAC,EAAI,IAAI,CAAC,CAClF,GAAIlB,CAAC,CAACe,MAAM,GAAK,OAAO,EAAIf,CAAC,CAACe,MAAM,CAACN,KAAK,CAAC,UAAU,CAAC,CAAE,CACtDW,MAAM,CAACnD,IAAI,CAAC,OAAO,CAAC,C,CAGtB,IAAK,GAAI,CAAAoC,CAAC,CAAG,CAAC,CAAEA,CAAC,CAAGgB,IAAI,CAACC,GAAG,CAACN,MAAM,CAACd,MAAM,CAAEkB,MAAM,CAAClB,MAAM,CAAC,CAAEG,CAAC,EAAE,CAAE,CAE/D,GAAIW,MAAM,CAACX,CAAC,CAAC,EAAI,IAAI,CAAE,CACrB,MAAO,EAAC,C,CAGV,GAAIe,MAAM,CAACf,CAAC,CAAC,EAAI,IAAI,CAAE,CACrB,MAAO,CAAC,CAAC,C,CAGX,KAAM,CAAAkB,SAAS,CAAGP,MAAM,CAACX,CAAC,CAAC,CAACM,UAAU,CAAC,GAAG,CAAC,CAC3C,KAAM,CAAAa,SAAS,CAAGJ,MAAM,CAACf,CAAC,CAAC,CAACM,UAAU,CAAC,GAAG,CAAC,CAE3C,GAAIY,SAAS,EAAIC,SAAS,CAAE,CAC1B,KAAM,CAAAC,SAAS,CAAGT,MAAM,CAACX,CAAC,CAAC,CAACI,KAAK,CAAC,gBAAgB,CAAC,CACnD,KAAM,CAAAiB,SAAS,CAAGN,MAAM,CAACf,CAAC,CAAC,CAACI,KAAK,CAAC,gBAAgB,CAAC,CAEnD,GAAIgB,SAAS,EAAIC,SAAS,CAAE,CAC1B,S,CACD,IAAM,IAAID,SAAS,CAAE,CACpB,MAAO,EAAC,C,CACT,IAAM,IAAIC,SAAS,CAAE,CACpB,MAAO,CAAC,CAAC,C,CAEX,S,CAGF,GAAIH,SAAS,CAAE,CACb,MAAO,EAAC,C,CAGV,GAAIC,SAAS,CAAE,CACb,MAAO,CAAC,CAAC,C,CAGX,KAAM,CAAAG,KAAK,CAAGX,MAAM,CAACX,CAAC,CAAC,CAACM,UAAU,CAAC,GAAG,CAAC,CACvC,KAAM,CAAAiB,KAAK,CAAGR,MAAM,CAACf,CAAC,CAAC,CAACM,UAAU,CAAC,GAAG,CAAC,CAEvC,GAAIgB,KAAK,EAAIC,KAAK,CAAE,CAClB,KAAM,CAAAH,SAAS,CAAGT,MAAM,CAACX,CAAC,CAAC,CAACI,KAAK,CAAC,gBAAgB,CAAC,CACnD,KAAM,CAAAiB,SAAS,CAAGN,MAAM,CAACf,CAAC,CAAC,CAACI,KAAK,CAAC,gBAAgB,CAAC,CAEnD,GAAIgB,SAAS,EAAIC,SAAS,CAAE,CAC1B,S,CACD,IAAM,IAAID,SAAS,CAAE,CACpB,MAAO,EAAC,C,CACT,IAAM,IAAIC,SAAS,CAAE,CACpB,MAAO,CAAC,CAAC,C,CAGX,S,CAGF,GAAIC,KAAK,CAAE,CACT,MAAO,EAAC,C,CAGV,GAAIC,KAAK,CAAE,CACT,MAAO,CAAC,CAAC,C,EAMb,GAAI7B,CAAC,CAACf,SAAS,EAAI,CAACgB,CAAC,CAAChB,SAAS,CAAE,CAC/B,MAAO,CAAC,CAAC,C,CAEX,GAAI,CAACe,CAAC,CAACf,SAAS,EAAIgB,CAAC,CAAChB,SAAS,CAAE,CAC/B,MAAO,EAAC,C,CAGV,MAAO,CAAAoC,MAAM,CAAClB,MAAM,CAAGc,MAAM,CAACd,MAAM,CACtC,CAEA,QAAS,CAAA2B,gCAAgCA,CACvCjF,IAAY,CACZkF,IAAY,CACZpE,OAAsB,CACtBD,aAAmC,EAMnC,KAAM,CAAAsE,SAAS,CAAGrE,OAAO,CACtBuD,MAAM,CAAEnC,MAAM,EAAK,CAACA,MAAM,CAACgB,WAAW,CAAC,CACvCxB,GAAG,CAAE0D,KAAK,EAAI,CACb,OAAAjD,aAAA,CAAAA,aAAA,IACKiD,KAAK,MAGRpF,IAAI,CAAE,GAAAF,UAAA,CAAAuF,0BAA0B,EAACD,KAAK,CAACpF,IAAI,CAAC,GAEhD,CAAC,CAAC,CAEJ,KAAM,CAAA6D,KAAK,CACTsB,SAAS,CAACG,IAAI,CACXpD,MAAM,EAELA,MAAM,CAAClC,IAAI,GAAK,EAAE,GAAK,CAACkC,MAAM,CAACY,KAAK,EAAIZ,MAAM,CAACY,KAAK,CAACyC,IAAI,CAAC,EAAE,CAAC,CAAC,CACjE,EACDJ,SAAS,CAACG,IAAI,CACXpD,MAAM,EAELA,MAAM,CAAClC,IAAI,CAAC+D,UAAU,CAAC,GAAG,CAAC,EAAI7B,MAAM,CAACY,KAAM,CAACyC,IAAI,CAAC,EAAE,CAAC,CACxD,EAGDJ,SAAS,CAACG,IAAI,CAAEpD,MAAM,EAAKA,MAAM,CAAClC,IAAI,CAAC+D,UAAU,CAAC,GAAG,CAAC,EAAI7B,MAAM,CAACY,KAAM,CAACyC,IAAI,CAAC,GAAG,CAAC,CAAC,CAEpF,GAAI,CAAC1B,KAAK,CAAE,CACV,MAAO,CAAA2B,SAAS,C,CAGlB,KAAM,CAAAC,MAAM,CAAG5B,KAAK,CAACvB,UAAU,CAACZ,GAAG,CAAEgE,IAAI,EAAI,CAC3C,GAAI,CAAC7B,KAAK,CAAC8B,MAAM,CAAE,CACjB,MAAO,CAAED,IAAI,CAAE,C,CAEjB,MAAO,CACLA,IAAI,CACJC,MAAM,CAAE9B,KAAK,CAAC8B,M,CACf,CACH,CAAC,CAAC,CAEF,MAAO,CAAAC,uBAAuB,CAAC5F,IAAI,CAAEkF,IAAI,CAAEO,MAAM,CAAE3E,OAAO,CAAED,aAAa,CAAC,CAC5E,CAEA,QAAS,CAAAG,2BAA2BA,CAClChB,IAAY,CACZc,OAAsB,CACtBD,aAAmC,CACnCZ,OAAA,GAAuD,EAEvD,KAAM,CAAA4F,cAAc,CAAG9F,oCAAoC,CAACC,IAAI,CAAC,CAEjE,GAAI,CAAC6F,cAAc,CAACvF,GAAG,CAAE,OAEzB,GAAI,CAAAwF,SAAS,CACXtF,YAAY,CAAC,GAAAV,UAAA,CAAAuF,0BAA0B,EAACQ,cAAc,CAACvF,GAAG,CAACC,QAAQ,CAAC,CAAEN,OAAO,CAAC,CAC9E4F,cAAc,CAACvF,GAAG,CAACyF,MAAM,CAE3B,GAAI,CAAC/F,IAAI,CAAC+D,UAAU,CAAC,GAAG,CAAC,CAAE+B,SAAS,CAAGA,SAAS,CAACE,KAAK,CAAC,CAAC,CAAC,CAEzD,GAAIH,cAAc,CAACzF,mBAAmB,GAAK,GAAG,CAAE,CAC9C,MAAO,CAAA6E,gCAAgC,CACrCa,SAAS,CACTD,cAAc,CAACvF,GAAG,CAAC4E,IAAI,CAACc,KAAK,CAAC,CAAC,CAAC,CAChClF,OAAO,CACPD,aAAa,CACd,C,CAKH,KAAM,CAAA4E,MAAM,CAAGQ,mBAAmB,CAACJ,cAAc,CAACzF,mBAAmB,CAAEU,OAAO,CAAC,CAE/E,GAAI2E,MAAM,EAAI,IAAI,CAAE,CAClB,MAAO,CAAAD,SAAS,C,CAGlB,MAAO,CAAAI,uBAAuB,CAC5BE,SAAS,CACTD,cAAc,CAACvF,GAAG,CAAC4E,IAAI,CAACc,KAAK,CAAC,CAAC,CAAC,CAChCP,MAAM,CACN3E,OAAO,CACPD,aAAa,CACd,CACH,CAEA,KAAM,CAAAmB,SAAS,CAAGA,CAAC,GAAGkE,KAAe,GAClC,EAAe,CACbC,MAAM,CAAC,GAAGD,KAAK,CAACxE,GAAG,CAAE0E,CAAC,EAAKA,CAAC,CAACzC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CACzCU,MAAM,CAACgC,OAAO,CAAC,CACf9D,IAAI,CAAC,GAAG,CAAC,CAEd,QAAS,CAAA0D,mBAAmBA,CAACK,SAAiB,CAAExF,OAAsB,EACpE,GAAI,CAAA2E,MAAiC,CACrC,GAAI,CAAAc,aAAa,CAAGD,SAAS,CAG7B,IAAK,KAAM,CAAApE,MAAM,GAAI,CAAApB,OAAO,CAAE,CAC5B,GAAI,CAACoB,MAAM,CAACY,KAAK,CAAE,CACjB,S,CAGF,KAAM,CAAAe,KAAK,CAAG0C,aAAa,CAAC1C,KAAK,CAAC3B,MAAM,CAACY,KAAK,CAAC,CAG/C,GAAI,CAACe,KAAK,CAAE,CACV,S,CAIF,KAAM,CAAA2C,aAAa,CAAGtE,MAAM,CAACc,OAAO,EAChCW,KAAK,CAAC,GAAG,CAAC,CACXU,MAAM,CAAE+B,CAAC,EAAKA,CAAC,CAACvC,KAAK,CAAC,OAAO,CAAC,CAAC,CAC/BlB,MAAM,CAAsB,CAACC,GAAG,CAAEwD,CAAC,CAAE3C,CAAC,GAAI,CACzC,GAAI2C,CAAC,CAACvC,KAAK,CAAC,KAAK,CAAC,CAAE,CAClB,OAAA1B,aAAA,CAAAA,aAAA,IACKS,GAAG,MACN,CAACwD,CAAC,EAAGvC,KAAM,CAAC,CAACJ,CAAC,CAAG,CAAC,EAAI,CAAC,CAAC,G,CAG5B,MAAO,CAAAjC,MAAM,CAACyC,MAAM,CAACrB,GAAG,CAAE,CAGxB,CAACwD,CAAC,EAAGvC,KAAM,CAAC,CAACJ,CAAC,CAAG,CAAC,EAAI,CAAC,CAAC,EAAEhD,OAAO,CAAC,IAAI,CAAE,EAAE,C,CAC3C,CAAC,CACJ,CAAC,CAAE,EAAE,CAAC,CAER,KAAM,CAAAgG,aAAa,CAAIf,IAAY,EAAI,CACrC,KAAM,CAAAxD,MAAM,CAAGpB,OAAO,CAACwE,IAAI,CAAEoB,CAAC,EAAKA,CAAC,CAACvC,MAAM,GAAKuB,IAAI,CAAC,CACrD,GAAI,CAACxD,MAAM,EAAElC,IAAI,CAAE,CACjB,MAAO,CAAE0F,IAAI,CAAE,C,CAGjB,KAAM,CAAAiB,QAAQ,CAAGzE,MAAM,CAAClC,IAAI,CAAC2D,KAAK,CAAC,GAAG,CAAC,CAEvC,KAAM,CAAAiD,MAAM,CAAwB,EAAE,CAEtCD,QAAQ,CACLtC,MAAM,CAAE+B,CAAC,EAAKA,CAAC,CAACvC,KAAK,CAAC,OAAO,CAAC,CAAC,CAC/BgD,OAAO,CAAET,CAAC,EAAI,CACb,GAAI,CAAAhB,KAAK,CAAGoB,aAAa,CAACJ,CAAC,CAAC,CAC5B,GAAIhB,KAAK,CAAE,CACT,GAAIgB,CAAC,CAACvC,KAAK,CAAC,KAAK,CAAC,CAAE,CAElBuB,KAAK,CAAGA,KAAK,EAAEzB,KAAK,CAAC,GAAG,CAAC,CAACU,MAAM,CAACgC,OAAO,CAAC,C,CAG3C,KAAM,CAAA1E,GAAG,CAAGyE,CAAC,CAAC3F,OAAO,CAAC,OAAO,CAAE,EAAE,CAAC,CAACA,OAAO,CAAC,KAAK,CAAE,EAAE,CAAC,CACrDmG,MAAM,CAACjF,GAAG,CAAC,CAAGO,MAAM,CAAC4E,KAAK,GAAGnF,GAAG,CAAC,CAAGO,MAAM,CAAC4E,KAAK,CAACnF,GAAG,CAAC,CAACyD,KAAK,CAAC,CAAGA,KAAK,C,CAExE,CAAC,CAAC,CAEJ,GAAIwB,MAAM,EAAIpF,MAAM,CAACC,IAAI,CAACmF,MAAM,CAAC,CAACtD,MAAM,CAAE,CACxC,MAAO,CAAEoC,IAAI,CAAEkB,MAAM,CAAE,C,CAGzB,MAAO,CAAElB,IAAI,CAAE,CACjB,CAAC,CAEDD,MAAM,CAAGvD,MAAM,CAACI,UAAU,CAACZ,GAAG,CAAEgE,IAAI,EAAI,CACtC,GAAI,CAACxD,MAAM,CAACyD,MAAM,CAAE,CAClB,OAAAxD,aAAA,IAAYsE,aAAa,CAACf,IAAI,CAAC,E,CAEjC,OAAAvD,aAAA,CAAAA,aAAA,IACKsE,aAAa,CAACf,IAAI,CAAC,MACtBC,MAAM,CAAEzD,MAAM,CAACyD,MAAM,GAEzB,CAAC,CAAC,CAGF,KAAM,CAAAoB,cAAc,CAAGtB,MAAM,CAAC9C,MAAM,CAClC,CAACC,GAAG,CAAEoE,CAAC,GAAKxF,MAAM,CAACyC,MAAM,CAACrB,GAAG,CAAEoE,CAAC,CAACJ,MAAM,CAAC,CACxC,EAAE,CACH,CAED,KAAM,CAAAK,iBAAiB,CAAGzF,MAAM,CAACC,IAAI,CAACsF,cAAc,CAAC,CAACzD,MAAM,CAAG,CAAC,CAGhEmC,MAAM,CAAGA,MAAM,CAAC/D,GAAG,CAAEsF,CAAC,EAAI,CACxB,GAAIC,iBAAiB,CAAE,CACrBD,CAAC,CAACJ,MAAM,CAAGG,cAAc,C,CAE3B,MAAO,CAAAC,CAAC,CACV,CAAC,CAAC,CAEFT,aAAa,CAAGA,aAAa,CAAC9F,OAAO,CAACoD,KAAK,CAAC,CAAC,CAAC,CAAE,EAAE,CAAC,CAEnD,M,CAGF,MAAO,CAAA4B,MAAM,CACf,CAEA,QAAS,CAAAyB,aAAaA,CAAC/D,CAAW,CAAEC,CAAW,EAC7C,GAAID,CAAC,CAACG,MAAM,GAAKF,CAAC,CAACE,MAAM,CAAE,CACzB,MAAO,MAAK,C,CAEd,IAAK,GAAI,CAAAG,CAAC,CAAG,CAAC,CAAEA,CAAC,CAAGN,CAAC,CAACG,MAAM,CAAEG,CAAC,EAAE,CAAE,CACjC,GAAIN,CAAC,CAACM,CAAC,CAAC,CAACS,aAAa,CAACd,CAAC,CAACK,CAAC,CAAC,CAAC,GAAK,CAAC,CAAE,CAClC,MAAO,MAAK,C,EAGhB,MAAO,KAAI,CACb,CAEA,KAAM,CAAA7B,uBAAuB,CAAGA,CAC9BuC,MAAc,CACdgD,WAAkC,CAClC7E,UAAA,CAAuB,EAAE,CACzB8E,QAAA,CAAiC,EAAE,CACnC9F,aAAA,CAA0B,EAAE,CAC5B+F,aAAsB,GACL,CACjB,KAAM,CAAAvG,OAAO,CAAkB,EAAE,CAEjCwB,UAAU,CAACjB,IAAI,CAAC8C,MAAM,CAAC,CAEvB7C,aAAa,CAACD,IAAI,CAAC8C,MAAM,CAAC,CAE1B,KAAM,CAAAjC,MAAM,CAAIiF,WAAmB,CAAChD,MAAM,CAAC,CAE3C,GAAI,MAAO,CAAAjC,MAAM,GAAK,QAAQ,CAAE,CAI9B,KAAM,CAAAc,OAAO,CAAGqE,aAAa,CAAGrF,SAAS,CAACqF,aAAa,CAAEnF,MAAM,CAAC,CAAGA,MAAM,CAEzEpB,OAAO,CAACO,IAAI,CAACiG,gBAAgB,CAACnD,MAAM,CAAE7B,UAAU,CAAEU,OAAO,CAAEd,MAAM,CAAE,KAAK,CAAC,CAAC,C,CAC3E,IAAM,IAAI,MAAO,CAAAA,MAAM,GAAK,QAAQ,CAAE,CACrC,GAAI,CAAAc,OAA2B,CAE/B,KAAM,CAAE2C,MAAM,CAAE,CAAGzD,MAAM,CAIzB,GAAI,MAAO,CAAAA,MAAM,CAAClC,IAAI,GAAK,QAAQ,CAAE,CACnC,GAAIkC,MAAM,CAACqF,KAAK,EAAIrF,MAAM,CAAClC,IAAI,GAAKwF,SAAS,CAAE,CAC7C,KAAM,IAAI,CAAArE,KAAK,CACb,sJAAsJ,CACvJ,C,CAGH6B,OAAO,CACLd,MAAM,CAACqF,KAAK,GAAK,IAAI,CACjBvF,SAAS,CAACqF,aAAa,EAAI,EAAE,CAAEnF,MAAM,CAAClC,IAAI,EAAI,EAAE,CAAC,CACjDkC,MAAM,CAAClC,IAAI,EAAI,EAAE,CAEvBc,OAAO,CAACO,IAAI,CACViG,gBAAgB,CACdnD,MAAM,CACN7B,UAAU,CACVU,OAAQ,CACRd,MAAM,CAAClC,IAAI,CACXkC,MAAM,CAAChB,OAAO,CAAG,CAAC,CAACM,MAAM,CAACC,IAAI,CAACS,MAAM,CAAChB,OAAO,CAAC,EAAEoC,MAAM,CAAG,KAAK,CAC9DpB,MAAM,CAAC4E,KAAK,CACZnB,MAAM,CACP,CACF,C,CAGH,GAAIzD,MAAM,CAAChB,OAAO,CAAE,CAElB,GAAIgB,MAAM,CAACd,gBAAgB,CAAE,CAC3BgG,QAAQ,CAAC/F,IAAI,CAAC,CACZD,gBAAgB,CAAEc,MAAM,CAACd,gBAAgB,CACzCE,a,CACD,CAAC,C,CAGJE,MAAM,CAACC,IAAI,CAACS,MAAM,CAAChB,OAAO,CAAC,CAAC2F,OAAO,CAAEW,YAAY,EAAI,CACnD,KAAM,CAAAC,MAAM,CAAG7F,uBAAuB,CACpC4F,YAAY,CACZtF,MAAM,CAAChB,OAAgC,CACvCoB,UAAU,CACV8E,QAAQ,CACR,CAAC,GAAG9F,aAAa,CAAC,CAClB0B,OAAO,EAAIqE,aAAa,CACzB,CAEDvG,OAAO,CAACO,IAAI,CAAC,GAAGoG,MAAM,CAAC,CACzB,CAAC,CAAC,C,EAINnF,UAAU,CAACsB,GAAG,EAAE,CAEhB,MAAO,CAAA9C,OAAO,CAChB,CAAC,CAED,QAAS,CAAA4G,kBAAkBA,CAAClE,EAAU,EAEpCA,EAAE,CAAGA,EAAE,CAAC/C,OAAO,CAAC,GAAG,CAAE,KAAK,CAAC,CAE3B,GAAI+C,EAAE,CAACO,UAAU,CAAC,GAAG,CAAC,CAAE,CAEtB,MAAO,cAAcP,EAAE,CAACmE,QAAQ,CAAC,GAAG,CAAC,CAAG,GAAG,CAAG,EAAE,GAAG,C,CACpD,IAAM,IAAInE,EAAE,CAACO,UAAU,CAAC,GAAG,CAAC,CAAE,CAC7B,MAAO,WAAWP,EAAE,CAACmE,QAAQ,CAAC,GAAG,CAAC,CAAG,GAAG,CAAG,EAAE,GAAG,C,CAIlD,GAAI,GAAA7H,UAAA,CAAAyE,cAAc,EAACf,EAAE,CAAC,EAAI,IAAI,CAAE,CAI9B,MAAO,MAAM,GAAA/D,sBAAA,CAAAwB,OAAM,EAACuC,EAAE,CAAC,OAAO,C,CAGhC,MAAO,GAAA/D,sBAAA,CAAAwB,OAAM,EAACuC,EAAE,CAAC,CAAG,KAAK,CAC3B,CAEA,KAAM,CAAA8D,gBAAgB,CAAGA,CACvBnD,MAAc,CACd7B,UAAoB,CACpBU,OAAe,CACfhD,IAAY,CACZkD,WAAqB,CACrB4D,KAAmB,CACnBnB,MAAY,GACG,CAEf3C,OAAO,CAAGA,OAAO,CAACW,KAAK,CAAC,GAAG,CAAC,CAACU,MAAM,CAACgC,OAAO,CAAC,CAAC9D,IAAI,CAAC,GAAG,CAAC,CAEtD,KAAM,CAAAO,KAAK,CAAGE,OAAO,CACjB,GAAI,CAAA4E,MAAM,CAAC,KAAK5E,OAAO,CAACW,KAAK,CAAC,GAAG,CAAC,CAACjC,GAAG,CAACgG,kBAAkB,CAAC,CAACnF,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,CACxEiD,SAAS,CAEb,MAAO,CACLrB,MAAM,CACNrB,KAAK,CACLE,OAAO,CACPhD,IAAI,CAEJsC,UAAU,CAAE,CAAC,GAAGA,UAAU,CAAC,CAC3BwE,KAAK,CACL9C,gBAAgB,CAAE,CAAC,GAAG1B,UAAU,CAAC0D,KAAK,CAAC,CAAC,CAAE,CAAC,CAAC,CAAC,CAAEhG,IAAI,EAAImE,MAAM,CAAC,CAAC5B,IAAI,CAAC,GAAG,CAAC,CACxEW,WAAW,CAAE,CAAC,CAACA,WAAW,CAC1ByC,M,CACD,CACH,CAAC,CAED,KAAM,CAAAkC,uBAAuB,CAAGA,CAC9BC,SAAiB,CACjBC,YAA2B,GACA,CAC3B,IAAK,KAAM,CAAA7F,MAAM,GAAI,CAAA6F,YAAY,CAAE,CACjC,GAAID,SAAS,GAAK5F,MAAM,CAACI,UAAU,CAACJ,MAAM,CAACI,UAAU,CAACgB,MAAM,CAAG,CAAC,CAAC,CAAE,CACjE,MAAO,CAAApB,MAAM,CAAC4E,KAAK,C,EAIvB,MAAO,CAAAtB,SAAS,CAClB,CAAC,CAGD,KAAM,CAAAwC,gBAAgB,CAAGA,CACvBF,SAAiB,CACjBxG,aAAuB,CACvBT,aAAmC,GACb,CACtB,IAAK,KAAM,CAAAqB,MAAM,GAAI,CAAArB,aAAa,CAAE,CAClC,GAAIqG,aAAa,CAAC5F,aAAa,CAAEY,MAAM,CAACZ,aAAa,CAAC,CAAE,CAGtD,MAAO,CAAAwG,SAAS,GAAK5F,MAAM,CAACd,gBAAgB,CAAGc,MAAM,CAACd,gBAAgB,CAAGoE,SAAS,C,EAGtF,MAAO,CAAAA,SAAS,CAClB,CAAC,CAID,KAAM,CAAAyC,iBAAiB,CAAGA,CACxBlG,KAAkB,CAClBmG,OAAgB,CAChBC,YAAqB,GACL,CAChB,GAAID,OAAO,CAAE,CACX,GAAIC,YAAY,CAAE,CAChB,MAAO,CACLC,KAAK,CAAE,CAAC,CACR3C,MAAM,CAAE,CAAC,CAAEC,IAAI,CAAEyC,YAAY,CAAE,CAAEpG,KAAK,C,CACvC,C,CAEH,MAAO,CACL0D,MAAM,CAAE,CAAC1D,KAAK,C,CACf,C,CAGH,GAAIoG,YAAY,CAAE,CAChB,MAAO,CACLC,KAAK,CAAE,CAAC,CACR3C,MAAM,CAAE,CAAC,CAAEC,IAAI,CAAEyC,YAAY,CAAE,CAAAhG,aAAA,CAAAA,aAAA,IAAOJ,KAAK,MAAEsG,KAAK,CAAE,CAAE5C,MAAM,CAAE,EAAE,CAAE,G,CACnE,C,CAEH,MAAO,CACLA,MAAM,CAAE,CAAAtD,aAAA,CAAAA,aAAA,IAAMJ,KAAK,MAAEsG,KAAK,CAAE,CAAE5C,MAAM,CAAE,EAAE,CAAE,G,CAC3C,CACH,CAAC,CAED,KAAM,CAAAG,uBAAuB,CAAGA,CAC9B5F,IAAY,CACZkF,IAAwB,CACxBO,MAAqB,CACrBsC,YAA2B,CAC3BlH,aAAmC,GACjC,CACF,GAAI,CAAAkB,KAAK,CAAG0D,MAAM,CAAC6C,KAAK,EAAiB,CACzC,KAAM,CAAAhH,aAAa,CAAa,EAAE,CAElC,GAAI,CAAA6G,YAAY,CAAGH,gBAAgB,CAACjG,KAAK,CAAC2D,IAAI,CAAEpE,aAAa,CAAET,aAAa,CAAC,CAE7ES,aAAa,CAACD,IAAI,CAACU,KAAK,CAAC2D,IAAI,CAAC,CAE9B,KAAM,CAAA2C,KAAK,CAAiBJ,iBAAiB,CAAClG,KAAK,CAAE0D,MAAM,CAACnC,MAAM,GAAK,CAAC,CAAE6E,YAAY,CAAC,CAEvF,GAAI1C,MAAM,CAACnC,MAAM,CAAG,CAAC,CAAE,CACrB,GAAI,CAAAiF,WAAW,CAAGF,KAAK,CAEvB,MAAQtG,KAAK,CAAG0D,MAAM,CAAC6C,KAAK,EAAiB,CAAG,CAC9CH,YAAY,CAAGH,gBAAgB,CAACjG,KAAK,CAAC2D,IAAI,CAAEpE,aAAa,CAAET,aAAa,CAAC,CAEzE,KAAM,CAAA2H,gBAAgB,CAAGD,WAAW,CAACH,KAAK,EAAIG,WAAW,CAAC9C,MAAM,CAACnC,MAAM,CAAG,CAAC,CAE3EiF,WAAW,CAAC9C,MAAM,CAAC+C,gBAAgB,CAAC,CAACH,KAAK,CAAGJ,iBAAiB,CAC5DlG,KAAK,CACL0D,MAAM,CAACnC,MAAM,GAAK,CAAC,CACnB6E,YAAY,CACb,CAED,GAAI1C,MAAM,CAACnC,MAAM,CAAG,CAAC,CAAE,CACrBiF,WAAW,CAAGA,WAAW,CAAC9C,MAAM,CAAC+C,gBAAgB,CAAC,CAACH,KAAqB,C,CAG1E/G,aAAa,CAACD,IAAI,CAACU,KAAK,CAAC2D,IAAI,CAAC,C,EAIlC3D,KAAK,CAAG,GAAAnC,kBAAA,CAAA6I,gBAAgB,EAACJ,KAAK,CAAgB,CAG9CtG,KAAK,CAAC/B,IAAI,CAAGA,IAAI,CAEjB,KAAM,CAAA4G,MAAM,CAAG8B,gBAAgB,CAAC3G,KAAK,CAAC/B,IAAI,CAAE6H,uBAAuB,CAAC9F,KAAK,CAAC2D,IAAI,CAAEqC,YAAY,CAAC,CAAC,CAE9F,GAAInB,MAAM,CAAE,CACV7E,KAAK,CAAC6E,MAAM,CAAGpF,MAAM,CAACyC,MAAM,CAACzC,MAAM,CAACmH,MAAM,CAAC,IAAI,CAAC,CAAE5G,KAAK,CAAC6E,MAAM,CAAwB,CACtF,IAAK,KAAM,CAAClB,IAAI,CAAEN,KAAK,CAAC,EAAI,CAAA5D,MAAM,CAACoH,OAAO,CAAChC,MAAM,CAAC,CAAE,CAClD,GAAI7E,KAAK,CAAC6E,MAAM,GAAGlB,IAAI,CAAC,CAAE,CACxB,SAA2C,CACzCmD,OAAO,CAACC,IAAI,CACV,WAAW/G,KAAK,CAAC2D,IAAI,iBAAiBA,IAAI,qEAAqE,CAChH,C,EAIL,GAAI,CAAC3D,KAAK,CAAC6E,MAAM,GAAGlB,IAAI,CAAC,CAAE,CACzB3D,KAAK,CAAC6E,MAAM,CAAClB,IAAI,CAAC,CAAGN,KAAK,CAC1B,S,EAIJ,GAAI5D,MAAM,CAACC,IAAI,CAACM,KAAK,CAAC6E,MAAM,CAAC,CAACtD,MAAM,GAAK,CAAC,CAAE,CAC1C,MAAO,CAAAvB,KAAK,CAAC6E,MAAM,C,EAIvB,GAAI1B,IAAI,CAAE,CACRnD,KAAK,CAAC6E,MAAM,CAAGpF,MAAM,CAACyC,MAAM,CAACzC,MAAM,CAACmH,MAAM,CAAC,IAAI,CAAC,CAAE5G,KAAK,CAAC6E,MAAM,CAAwB,CACtF7E,KAAK,CAAC6E,MAAM,CAAC,GAAG,CAAC,CAAG1B,IAAI,C,CAG1B,MAAO,CAAAmD,KAAK,CACd,CAAC,CAED,KAAM,CAAAK,gBAAgB,CAAGA,CAAC1I,IAAY,CAAE+I,WAAoD,GAAI,CAC9F,KAAM,CAAAC,KAAK,CAAGhJ,IAAI,CAAC2D,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,CAChC,KAAM,CAAAsF,YAAY,CAAG,GAAI,CAAAC,eAAe,CAACF,KAAK,CAAC,CAC/C,KAAM,CAAApC,MAAM,CAAGpF,MAAM,CAAC2H,WAAW,CAE/BF,YAAY,CACb,CAED,GAAIF,WAAW,CAAE,CACfvH,MAAM,CAACC,IAAI,CAACmF,MAAM,CAAC,CAACC,OAAO,CAAEnB,IAAI,EAAI,CACnC,GAAIlE,MAAM,CAAC4H,cAAc,CAACC,IAAI,CAACN,WAAW,CAAErD,IAAI,CAAC,EAAI,MAAO,CAAAkB,MAAM,CAAClB,IAAI,CAAC,GAAK,QAAQ,CAAE,CACrFkB,MAAM,CAAClB,IAAI,CAAC,CAAGqD,WAAW,CAACrD,IAAI,CAAC,CAACkB,MAAM,CAAClB,IAAI,CAAW,CAAC,C,CAE5D,CAAC,CAAC,C,CAGJ,MAAO,CAAAlE,MAAM,CAACC,IAAI,CAACmF,MAAM,CAAC,CAACtD,MAAM,CAAGsD,MAAM,CAAGpB,SAAS,CACxD,CAAC,CAED,KAAM,CAAA8D,YAAY,CAAG,GAAI,CAAAC,GAAG,EAAkB,CAE9C,QAAS,CAAAC,eAAeA,CAACvJ,OAAe,EACtC,GAAIqJ,YAAY,CAACG,GAAG,CAACxJ,OAAO,CAAC,CAAE,CAC7B,MAAO,CAAAqJ,YAAY,CAACI,GAAG,CAACzJ,OAAO,CAAE,C,CAEnC,KAAM,CAAA6C,KAAK,CAAG,GAAI,CAAA8E,MAAM,CAAC,QAAQ,GAAAnI,sBAAA,CAAAwB,OAAM,EAAChB,OAAO,CAAC,EAAE,CAAE,GAAG,CAAC,CACxDqJ,YAAY,CAACK,GAAG,CAAC1J,OAAO,CAAE6C,KAAK,CAAC,CAChC,MAAO,CAAAA,KAAK,CACd,CAEA,QAAgB,CAAAtC,YAAYA,CAC1BR,IAAY,CACZC,OAAA,GAAuD,EAEvD,QAA4C,CAC1C,GAAIA,OAAO,CAAE,CACX,KAAM,CAAA2J,GAAG,CAAGJ,eAAe,CAACvJ,OAAO,CAAC,CACpC,MAAO,CAAAD,IAAI,CAACS,OAAO,CAAC,OAAO,CAAE,GAAG,CAAC,CAACA,OAAO,CAACmJ,GAAG,CAAE,EAAE,CAAC,C,EAGtD,MAAO,CAAA5J,IAAI,CACb,CAXAU,OAAA,CAAAF,YAAA,CAAAA,YAAA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}